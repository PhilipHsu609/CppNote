[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modern C++ Notes",
    "section": "",
    "text": "A study reference for Modern C++ programming, covering language features, standard library, and design patterns.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#sections",
    "href": "index.html#sections",
    "title": "Modern C++ Notes",
    "section": "Sections",
    "text": "Sections\n\nCore - Fundamental language features\nClasses - OOP and object model\nTemplates - Generic programming\nMemory - Memory and resource management\nStdlib - Standard library\nConcurrency - Parallel and async programming\nCompilation - Build model and linkage\nPatterns - Design patterns\nThird-Party - Popular libraries (fmt)",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html",
    "href": "docs/templates/sfinae.html",
    "title": "SFINAE",
    "section": "",
    "text": "Substitution Failure Is Not An Error.",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html#the-principle",
    "href": "docs/templates/sfinae.html#the-principle",
    "title": "SFINAE",
    "section": "The Principle",
    "text": "The Principle\nWhen template argument substitution fails, the specialization is discarded (not an error) and other overloads are tried.\ntemplate &lt;typename T&gt;\ntypename T::value_type get(T& container); // #1\n\ntemplate &lt;typename T&gt;\nT get(T* ptr); // #2\n\nint x;\nget(&x); // #1 fails (int* has no value_type), #2 selected",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html#stdenable_if",
    "href": "docs/templates/sfinae.html#stdenable_if",
    "title": "SFINAE",
    "section": "std::enable_if",
    "text": "std::enable_if\nConditionally enable overloads:\n// Enable only for signed types\ntemplate &lt;typename T, std::enable_if_t&lt;std::is_signed_v&lt;T&gt;, int&gt; = 0&gt;\nT ceil_div(T value, T div) {\n    return (value &gt; 0 && div &gt; 0) ? (value + div - 1) / div : value / div;\n}\n\n// Enable only for unsigned types\ntemplate &lt;typename T, std::enable_if_t&lt;!std::is_signed_v&lt;T&gt;, int&gt; = 0&gt;\nT ceil_div(T value, T div) {\n    return (value + div - 1) / div;\n}",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html#enable_if-as-return-type",
    "href": "docs/templates/sfinae.html#enable_if-as-return-type",
    "title": "SFINAE",
    "section": "enable_if as Return Type",
    "text": "enable_if as Return Type\ntemplate &lt;typename T&gt;\nstd::enable_if_t&lt;std::is_integral_v&lt;T&gt;, T&gt;\nprocess(T value) {\n    return value * 2;\n}",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html#stdvoid_t-c17",
    "href": "docs/templates/sfinae.html#stdvoid_t-c17",
    "title": "SFINAE",
    "section": "std::void_t (C++17)",
    "text": "std::void_t (C++17)\nDetects valid expressions:\n// Primary: false by default\ntemplate &lt;typename T, typename = void&gt;\nstruct has_member_x : std::false_type {};\n\n// Specialization: true if T has .x\ntemplate &lt;typename T&gt;\nstruct has_member_x&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().x)&gt;&gt;\n    : std::true_type {};\n\n// Helper variable\ntemplate &lt;typename T&gt;\ninline constexpr bool has_member_x_v = has_member_x&lt;T&gt;::value;\n\nstruct A { int x; };\nstruct B { };\n\nstatic_assert(has_member_x_v&lt;A&gt;);\nstatic_assert(!has_member_x_v&lt;B&gt;);",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html#how-void_t-works",
    "href": "docs/templates/sfinae.html#how-void_t-works",
    "title": "SFINAE",
    "section": "How void_t Works",
    "text": "How void_t Works\n// If decltype(T().x) is valid:\n//   void_t&lt;...&gt; = void\n//   Specialization matches (more specific)\n//\n// If invalid:\n//   SFINAE discards specialization\n//   Primary template selected (false_type)",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html#key-points",
    "href": "docs/templates/sfinae.html#key-points",
    "title": "SFINAE",
    "section": "Key Points",
    "text": "Key Points\n\nSFINAE: failed substitution removes overload, doesn’t error\nstd::enable_if conditionally enables templates\nstd::void_t detects valid types/expressions\nPrefer concepts (C++20) over SFINAE when possible",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/sfinae.html#see-also",
    "href": "docs/templates/sfinae.html#see-also",
    "title": "SFINAE",
    "section": "See Also",
    "text": "See Also\n\ntype-traits - type properties\nspecialization - template specialization",
    "crumbs": [
      "Templates",
      "SFINAE"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html",
    "href": "docs/templates/type-traits.html",
    "title": "Type Traits",
    "section": "",
    "text": "Compile-time type introspection and manipulation.",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#type-properties",
    "href": "docs/templates/type-traits.html#type-properties",
    "title": "Type Traits",
    "section": "Type Properties",
    "text": "Type Properties\n#include &lt;type_traits&gt;\n\n// Check properties\nstatic_assert(std::is_integral_v&lt;int&gt;);\nstatic_assert(std::is_floating_point_v&lt;double&gt;);\nstatic_assert(std::is_pointer_v&lt;int*&gt;);\nstatic_assert(std::is_reference_v&lt;int&&gt;);\nstatic_assert(std::is_const_v&lt;const int&gt;);\nstatic_assert(std::is_class_v&lt;std::string&gt;);\nstatic_assert(std::is_same_v&lt;int, int&gt;);",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#type-relationships",
    "href": "docs/templates/type-traits.html#type-relationships",
    "title": "Type Traits",
    "section": "Type Relationships",
    "text": "Type Relationships\nstatic_assert(std::is_base_of_v&lt;Base, Derived&gt;);\nstatic_assert(std::is_convertible_v&lt;Derived*, Base*&gt;);",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#type-manipulation",
    "href": "docs/templates/type-traits.html#type-manipulation",
    "title": "Type Traits",
    "section": "Type Manipulation",
    "text": "Type Manipulation\n// Add qualifiers\nstd::add_const_t&lt;int&gt;              // const int\nstd::add_pointer_t&lt;int&gt;            // int*\nstd::add_lvalue_reference_t&lt;int&gt;   // int&\n\n// Remove qualifiers\nstd::remove_const_t&lt;const int&gt;     // int\nstd::remove_pointer_t&lt;int*&gt;        // int\nstd::remove_reference_t&lt;int&&gt;      // int\n\n// Sign manipulation\nstd::make_signed_t&lt;unsigned int&gt;   // int\nstd::make_unsigned_t&lt;int&gt;          // unsigned int",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#stddecay",
    "href": "docs/templates/type-traits.html#stddecay",
    "title": "Type Traits",
    "section": "std::decay",
    "text": "std::decay\nRemoves reference, const, and array-to-pointer decay:\nstd::decay_t&lt;int&&gt;           // int\nstd::decay_t&lt;const int&&gt;     // int\nstd::decay_t&lt;int[3]&gt;         // int*\nstd::decay_t&lt;int(int)&gt;       // int(*)(int)",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#using-in-templates",
    "href": "docs/templates/type-traits.html#using-in-templates",
    "title": "Type Traits",
    "section": "Using in Templates",
    "text": "Using in Templates\ntemplate &lt;typename T&gt;\nvoid process(T t) {\n    if constexpr (std::is_integral_v&lt;T&gt;) {\n        // integer handling\n    } else if constexpr (std::is_floating_point_v&lt;T&gt;) {\n        // float handling\n    }\n}\n\ntemplate &lt;typename T&gt;\nT add(T a, T b) {\n    static_assert(std::is_arithmetic_v&lt;T&gt;, \"T must be arithmetic\");\n    return a + b;\n}",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#const-reference-gotcha",
    "href": "docs/templates/type-traits.html#const-reference-gotcha",
    "title": "Type Traits",
    "section": "Const Reference Gotcha",
    "text": "Const Reference Gotcha\n// Reference to const, not const reference\n// (references themselves can't be const)\nstatic_assert(std::is_same_v&lt;\n    std::remove_const_t&lt;const int&&gt;,\n    const int&  // const NOT removed!\n&gt;);\n\n// Remove reference first, then const\nstatic_assert(std::is_same_v&lt;\n    std::remove_const_t&lt;std::remove_reference_t&lt;const int&&gt;&gt;,\n    int\n&gt;);\n\n// Or use decay\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;const int&&gt;, int&gt;);",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#decltype",
    "href": "docs/templates/type-traits.html#decltype",
    "title": "Type Traits",
    "section": "decltype",
    "text": "decltype\nCaptures expression type:\nvoid f(int, int);\n\ndecltype(f)           // void(int, int)\ndecltype(f(1, 2))     // void\n\nint x;\ndecltype(x)           // int\ndecltype((x))         // int& (parentheses -&gt; lvalue ref)",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#stdaddressof",
    "href": "docs/templates/type-traits.html#stdaddressof",
    "title": "Type Traits",
    "section": "std::addressof",
    "text": "std::addressof\nGets address even with overloaded operator&:\nstruct Evil {\n    Evil* operator&() { return nullptr; }\n};\n\nEvil e;\nEvil* p1 = &e;              // nullptr (overloaded!)\nEvil* p2 = std::addressof(e); // actual address",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#key-points",
    "href": "docs/templates/type-traits.html#key-points",
    "title": "Type Traits",
    "section": "Key Points",
    "text": "Key Points\n\n_v suffix: value (bool/int)\n_t suffix: type\nstd::decay for “natural” type transformations\nRemove reference before const for compound types\nUse if constexpr with type traits for compile-time branching",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/type-traits.html#see-also",
    "href": "docs/templates/type-traits.html#see-also",
    "title": "Type Traits",
    "section": "See Also",
    "text": "See Also\n\nsfinae - conditional template instantiation",
    "crumbs": [
      "Templates",
      "Type Traits"
    ]
  },
  {
    "objectID": "docs/templates/specialization.html",
    "href": "docs/templates/specialization.html",
    "title": "Template Specialization",
    "section": "",
    "text": "Custom implementations for specific types.",
    "crumbs": [
      "Templates",
      "Template Specialization"
    ]
  },
  {
    "objectID": "docs/templates/specialization.html#full-specialization",
    "href": "docs/templates/specialization.html#full-specialization",
    "title": "Template Specialization",
    "section": "Full Specialization",
    "text": "Full Specialization\nAll template parameters specified:\ntemplate &lt;typename T&gt;\nbool equal(T a, T b) {\n    return a == b;\n}\n\n// Full specialization for float\ntemplate &lt;&gt;\nbool equal&lt;float&gt;(float a, float b) {\n    return std::abs(a - b) &lt; 1e-6f;\n}",
    "crumbs": [
      "Templates",
      "Template Specialization"
    ]
  },
  {
    "objectID": "docs/templates/specialization.html#partial-specialization-classes-only",
    "href": "docs/templates/specialization.html#partial-specialization-classes-only",
    "title": "Template Specialization",
    "section": "Partial Specialization (Classes Only)",
    "text": "Partial Specialization (Classes Only)\nSome template parameters specified:\ntemplate &lt;typename T, typename U&gt;\nstruct Pair {\n    T first;\n    U second;\n};\n\n// Partial: when U is int\ntemplate &lt;typename T&gt;\nstruct Pair&lt;T, int&gt; {\n    T first;\n    int second;\n    // Completely different implementation allowed\n};\n\n// Full: both specified\ntemplate &lt;&gt;\nstruct Pair&lt;float, double&gt; {\n    float x;\n    double y;\n};\nNote: Functions cannot be partially specialized (use overloading instead).",
    "crumbs": [
      "Templates",
      "Template Specialization"
    ]
  },
  {
    "objectID": "docs/templates/specialization.html#implementing-type-traits",
    "href": "docs/templates/specialization.html#implementing-type-traits",
    "title": "Template Specialization",
    "section": "Implementing Type Traits",
    "text": "Implementing Type Traits\n// Primary template\ntemplate &lt;typename T, typename U&gt;\nstruct is_same : std::false_type {};\n\n// Partial specialization: when T == U\ntemplate &lt;typename T&gt;\nstruct is_same&lt;T, T&gt; : std::true_type {};\n\nstatic_assert(is_same&lt;int, int&gt;::value);\nstatic_assert(!is_same&lt;int, float&gt;::value);",
    "crumbs": [
      "Templates",
      "Template Specialization"
    ]
  },
  {
    "objectID": "docs/templates/specialization.html#another-example-pointer-detection",
    "href": "docs/templates/specialization.html#another-example-pointer-detection",
    "title": "Template Specialization",
    "section": "Another Example: Pointer Detection",
    "text": "Another Example: Pointer Detection\ntemplate &lt;typename T&gt;\nstruct is_const_ptr : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_const_ptr&lt;const T*&gt; : std::true_type {};\n\nstatic_assert(is_const_ptr&lt;const int*&gt;::value);\nstatic_assert(!is_const_ptr&lt;int*&gt;::value);",
    "crumbs": [
      "Templates",
      "Template Specialization"
    ]
  },
  {
    "objectID": "docs/templates/specialization.html#key-points",
    "href": "docs/templates/specialization.html#key-points",
    "title": "Template Specialization",
    "section": "Key Points",
    "text": "Key Points\n\nFull specialization: all parameters specified\nPartial specialization: some parameters specialized\nSpecialized classes are completely new types\nFunctions use overloading instead of partial specialization\nType traits leverage partial specialization patterns",
    "crumbs": [
      "Templates",
      "Template Specialization"
    ]
  },
  {
    "objectID": "docs/templates/specialization.html#see-also",
    "href": "docs/templates/specialization.html#see-also",
    "title": "Template Specialization",
    "section": "See Also",
    "text": "See Also\n\nbasics - template basics\ntype-traits - standard type traits\nsfinae - conditional instantiation",
    "crumbs": [
      "Templates",
      "Template Specialization"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html",
    "href": "docs/templates/variadic.html",
    "title": "Variadic Templates",
    "section": "",
    "text": "Templates with variable number of arguments.",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#syntax",
    "href": "docs/templates/variadic.html#syntax",
    "title": "Variadic Templates",
    "section": "Syntax",
    "text": "Syntax\ntemplate &lt;typename... TArgs&gt;  // template parameter pack\nvoid f(TArgs... args) {       // function parameter pack\n    auto n = sizeof...(args); // number of arguments\n}\n\nf(1, 2.0, \"hello\"); // TArgs = &lt;int, double, const char*&gt;",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#recursive-expansion",
    "href": "docs/templates/variadic.html#recursive-expansion",
    "title": "Variadic Templates",
    "section": "Recursive Expansion",
    "text": "Recursive Expansion\n// Base case\ntemplate &lt;typename T&gt;\nT add(T a, T b) {\n    return a + b;\n}\n\n// Recursive case\ntemplate &lt;typename T, typename... TArgs&gt;\nT add(T first, TArgs... rest) {\n    return first + add(rest...);\n}\n\nadd(1, 2, 3, 4); // 1 + add(2, 3, 4) -&gt; ... -&gt; 10",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#pack-expansion",
    "href": "docs/templates/variadic.html#pack-expansion",
    "title": "Variadic Templates",
    "section": "Pack Expansion",
    "text": "Pack Expansion\ntemplate &lt;typename T&gt;\nT square(T x) { return x * x; }\n\ntemplate &lt;typename... TArgs&gt;\nauto sum_of_squares(TArgs... args) {\n    return add(square(args)...); // applies square to each\n}\n\nsum_of_squares(1, 2, 3); // square(1) + square(2) + square(3)",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#fold-expressions-c17",
    "href": "docs/templates/variadic.html#fold-expressions-c17",
    "title": "Variadic Templates",
    "section": "Fold Expressions (C++17)",
    "text": "Fold Expressions (C++17)\nMore elegant than recursion:\n// Unary right fold: (E1 op (E2 op (... op EN)))\ntemplate &lt;typename... T&gt;\nauto sum_right(T... args) {\n    return (args + ...);\n}\n\n// Unary left fold: (((E1 op E2) op ...) op EN)\ntemplate &lt;typename... T&gt;\nauto sum_left(T... args) {\n    return (... + args);\n}\n\n// Binary fold with init\ntemplate &lt;typename... T&gt;\nauto sum_init(T... args) {\n    return (0 + ... + args); // handles empty pack\n}",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#stream-output-with-fold",
    "href": "docs/templates/variadic.html#stream-output-with-fold",
    "title": "Variadic Templates",
    "section": "Stream Output with Fold",
    "text": "Stream Output with Fold\ntemplate &lt;typename... T&gt;\nvoid print(T... args) {\n    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; '\\n';\n}\n\nprint(1, \" + \", 2, \" = \", 3); // \"1 + 2 = 3\"",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#lambda-with-variadic-c14",
    "href": "docs/templates/variadic.html#lambda-with-variadic-c14",
    "title": "Variadic Templates",
    "section": "Lambda with Variadic (C++14)",
    "text": "Lambda with Variadic (C++14)\nauto print_all = [](auto... args) {\n    (std::cout &lt;&lt; ... &lt;&lt; args);\n};",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#key-points",
    "href": "docs/templates/variadic.html#key-points",
    "title": "Variadic Templates",
    "section": "Key Points",
    "text": "Key Points\n\n... after type: parameter pack\nargs...: pack expansion\nsizeof...(args): number of arguments\nFold expressions (C++17) simplify recursion\nLeft vs right fold matters for non-associative operators",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/templates/variadic.html#see-also",
    "href": "docs/templates/variadic.html#see-also",
    "title": "Variadic Templates",
    "section": "See Also",
    "text": "See Also\n\nbasics - template fundamentals\nmetaprogramming - compile-time computation",
    "crumbs": [
      "Templates",
      "Variadic Templates"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html",
    "href": "docs/memory/memory-order.html",
    "title": "Memory Ordering",
    "section": "",
    "text": "Control how atomic operations are ordered across threads.",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html#memory-order-options",
    "href": "docs/memory/memory-order.html#memory-order-options",
    "title": "Memory Ordering",
    "section": "Memory Order Options",
    "text": "Memory Order Options\nstd::memory_order_relaxed      // no ordering, only atomicity\nstd::memory_order_acquire      // read barrier\nstd::memory_order_release      // write barrier\nstd::memory_order_acq_rel      // both acquire and release\nstd::memory_order_seq_cst      // sequential consistency (default)",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html#sequential-consistency",
    "href": "docs/memory/memory-order.html#sequential-consistency",
    "title": "Memory Ordering",
    "section": "Sequential Consistency",
    "text": "Sequential Consistency\nAll threads see operations in the same order:\nstd::atomic&lt;bool&gt; x{false}, y{false};\nstd::atomic&lt;int&gt; z{0};\n\n// Thread 1\nx.store(true, std::memory_order_seq_cst);\n\n// Thread 2\ny.store(true, std::memory_order_seq_cst);\n\n// Thread 3\nwhile (!x.load(std::memory_order_seq_cst));\nif (y.load(std::memory_order_seq_cst)) ++z;\n\n// Thread 4\nwhile (!y.load(std::memory_order_seq_cst));\nif (x.load(std::memory_order_seq_cst)) ++z;\n\n// z is always 1 or 2, never 0",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html#relaxed-ordering",
    "href": "docs/memory/memory-order.html#relaxed-ordering",
    "title": "Memory Ordering",
    "section": "Relaxed Ordering",
    "text": "Relaxed Ordering\nOnly guarantees atomicity, no ordering:\nstd::atomic&lt;bool&gt; x{false}, y{false};\n\n// Thread 1\nx.store(true, std::memory_order_relaxed);\ny.store(true, std::memory_order_relaxed);\n\n// Thread 2\nwhile (!y.load(std::memory_order_relaxed));\n// x might still be false! (reordering allowed)",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html#acquire-release",
    "href": "docs/memory/memory-order.html#acquire-release",
    "title": "Memory Ordering",
    "section": "Acquire-Release",
    "text": "Acquire-Release\nSynchronizes producer and consumer:\nstd::atomic&lt;bool&gt; ready{false};\nint data;\n\n// Producer\ndata = 42;\nready.store(true, std::memory_order_release);\n\n// Consumer\nwhile (!ready.load(std::memory_order_acquire));\n// data is guaranteed to be 42\nRelease ensures all prior writes are visible. Acquire ensures all subsequent reads see those writes.",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html#when-to-use-what",
    "href": "docs/memory/memory-order.html#when-to-use-what",
    "title": "Memory Ordering",
    "section": "When to Use What",
    "text": "When to Use What\n\n\n\nUse Case\nMemory Order\n\n\n\n\nSimple counter\nrelaxed\n\n\nFlag/condition\nacquire/release\n\n\nDefault (safe)\nseq_cst",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html#key-points",
    "href": "docs/memory/memory-order.html#key-points",
    "title": "Memory Ordering",
    "section": "Key Points",
    "text": "Key Points\n\nseq_cst is safest but slowest\nrelaxed is fastest but provides no ordering\nacquire/release pairs synchronize specific operations\nMost code should use seq_cst unless performance-critical\nMemory ordering bugs are extremely hard to debug",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/memory/memory-order.html#see-also",
    "href": "docs/memory/memory-order.html#see-also",
    "title": "Memory Ordering",
    "section": "See Also",
    "text": "See Also\n\natomic - atomic operations",
    "crumbs": [
      "Memory",
      "Memory Ordering"
    ]
  },
  {
    "objectID": "docs/core/initialization.html",
    "href": "docs/core/initialization.html",
    "title": "Initialization",
    "section": "",
    "text": "How variables get their initial values.",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/initialization.html#zero-initialization",
    "href": "docs/core/initialization.html#zero-initialization",
    "title": "Initialization",
    "section": "Zero Initialization",
    "text": "Zero Initialization\nStatic/thread-local storage with no initializer:\nint w;              // zero (if global/static)\nstatic int x;       // zero\nextern int z;       // zero\nthread_local int y; // zero",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/initialization.html#default-initialization",
    "href": "docs/core/initialization.html#default-initialization",
    "title": "Initialization",
    "section": "Default Initialization",
    "text": "Default Initialization\nNo initializer provided:\nint i;                     // indeterminate value (if local)\nint* a = new int;          // indeterminate\nint* b = new int[5];       // each element indeterminate\nstd::string s;             // empty string (constructor called)\nFor non-POD types, the default constructor runs.",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/initialization.html#direct-initialization",
    "href": "docs/core/initialization.html#direct-initialization",
    "title": "Initialization",
    "section": "Direct Initialization",
    "text": "Direct Initialization\nExplicit value in parentheses or braces:\nint* a = new int(42);\nint b{23};\nint c(15);\n// int d(); // This declares a function!\n\nstd::string s(\"Hello\");\nstd::string t(5, 'a'); // \"aaaaa\"",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/initialization.html#value-initialization",
    "href": "docs/core/initialization.html#value-initialization",
    "title": "Initialization",
    "section": "Value Initialization",
    "text": "Value Initialization\nEmpty initializer {} or ():\nint i{};               // 0\nint j = int();         // 0\nint* a = new int();    // 0\nint* b = new int[5](); // all zeros\n\nValue Initialization of Structs\nstruct S1 {\n    int mem1;\n    std::string mem2;\n    virtual void foo() {} // makes S1 non-aggregate\n};\n\nstruct S3 {\n    int mem1;\n    std::string mem2;\n    S3() {} // user-provided default constructor\n};\n\nS1 s1{}; // mem1 = 0, mem2 = \"\" (zero + default init)\nS3 s3{}; // mem1 = indeterminate, mem2 = \"\" (only default init)\n\nImplicit constructor → zero-init then default-init\nUser-provided constructor → only default-init",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/initialization.html#list-initialization-c11",
    "href": "docs/core/initialization.html#list-initialization-c11",
    "title": "Initialization",
    "section": "List Initialization (C++11)",
    "text": "List Initialization (C++11)\nUsing braces {}:\nint x{5};\nstd::vector&lt;int&gt; v{1, 2, 3};\n\n// Direct-list-initialization (no =)\nstd::string s{\"hello\"};\n\n// Copy-list-initialization (with =)\nstd::string t = {\"hello\"};",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/initialization.html#key-points",
    "href": "docs/core/initialization.html#key-points",
    "title": "Initialization",
    "section": "Key Points",
    "text": "Key Points\n\nGlobal/static variables are zero-initialized\nLocal POD variables are uninitialized (garbage)\n{} value-initializes (zeros for POD)\n() after new value-initializes\nUser-provided constructors skip zero-initialization",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/initialization.html#see-also",
    "href": "docs/core/initialization.html#see-also",
    "title": "Initialization",
    "section": "See Also",
    "text": "See Also\n\nconstructors - class initialization\nallocation - dynamic allocation",
    "crumbs": [
      "Core",
      "Initialization"
    ]
  },
  {
    "objectID": "docs/core/types.html",
    "href": "docs/core/types.html",
    "title": "Types",
    "section": "",
    "text": "C++ type system: fundamental types, compound types, and type conversions.",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#fundamental-types",
    "href": "docs/core/types.html#fundamental-types",
    "title": "Types",
    "section": "Fundamental Types",
    "text": "Fundamental Types\n#include &lt;type_traits&gt;\n\n// Arithmetic types: bool, char, int, float, double\nstatic_assert(std::is_arithmetic_v&lt;bool&gt;);\nstatic_assert(std::is_arithmetic_v&lt;char&gt;);\nstatic_assert(std::is_arithmetic_v&lt;int&gt;);\nstatic_assert(std::is_arithmetic_v&lt;float&gt;);\nstatic_assert(std::is_arithmetic_v&lt;double&gt;);\n\n// void and std::nullptr_t\nstatic_assert(std::is_fundamental_v&lt;void&gt;);\nstatic_assert(std::is_fundamental_v&lt;std::nullptr_t&gt;);",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#compound-types",
    "href": "docs/core/types.html#compound-types",
    "title": "Types",
    "section": "Compound Types",
    "text": "Compound Types\n// Compound types include:\n// pointers, references, enumerators, arrays, structures, unions, classes, functions\n\nenum class Color { Red, Green, Blue };\nstruct Point { int x, y; };\nunion Data { int i; float f; };\n\nstatic_assert(std::is_compound_v&lt;int*&gt;);\nstatic_assert(std::is_compound_v&lt;int&&gt;);\nstatic_assert(std::is_compound_v&lt;int[10]&gt;);\nstatic_assert(std::is_compound_v&lt;Color&gt;);\nstatic_assert(std::is_compound_v&lt;Point&gt;);",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#nullptr",
    "href": "docs/core/types.html#nullptr",
    "title": "Types",
    "section": "nullptr",
    "text": "nullptr\nvoid foo(int* ptr);\nvoid foo(std::nullptr_t);\n\nint main() {\n    int* p{};\n    foo(p);       // calls foo(int*)\n    foo(nullptr); // calls foo(std::nullptr_t)\n    // foo(0) or foo(NULL) would be ambiguous\n}",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#type-conversions",
    "href": "docs/core/types.html#type-conversions",
    "title": "Types",
    "section": "Type Conversions",
    "text": "Type Conversions\n\nPromotion Rules\nApplied top to bottom (first match wins):\n// 1. Floating point promotion\nstatic_assert(std::is_same_v&lt;decltype(1.0f + 1), float&gt;);\n\n// 2. Integral promotion (small types -&gt; int)\nstatic_assert(std::is_same_v&lt;decltype('a' + 'b'), int&gt;);\nstd::uint8_t a = 255, b = 255;\nauto c = a + b; // = 510, no overflow (promoted to int)\n\n// 3. Size promotion\nstatic_assert(std::is_same_v&lt;decltype(1 + 1ll), long long&gt;);\n\n// 4. Signedness promotion (same size: unsigned wins)\nstatic_assert(std::is_same_v&lt;decltype(1u + 1), unsigned int&gt;);\n\n\nCast Operators\nint a = 5;\n\n// static_cast - compile-time type check\nfloat f = static_cast&lt;float&gt;(a);\n\n// const_cast - add/remove const/volatile\nconst int b = 10;\nint* p = const_cast&lt;int*&gt;(&b);\n*p = 20; // undefined behavior!\n\n// reinterpret_cast - bit-level conversion\nint c = reinterpret_cast&lt;int&&gt;(f);     // float bits as int\nauto addr = reinterpret_cast&lt;std::size_t&gt;(&f); // pointer to integer\n\n// Array reshape\nint arr[3][4] = {};\nint (&arr2)[2][6] = reinterpret_cast&lt;int(&)[2][6]&gt;(arr);",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#size-types",
    "href": "docs/core/types.html#size-types",
    "title": "Types",
    "section": "Size Types",
    "text": "Size Types\n#include &lt;cstddef&gt;\n\nstatic_assert(std::is_same_v&lt;std::size_t, unsigned long&gt;);\nstatic_assert(std::is_signed_v&lt;std::ptrdiff_t&gt;);\n\nstd::size_t - unsigned type for sizes and counts\nstd::ptrdiff_t - signed type for pointer differences",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#operator-associativity",
    "href": "docs/core/types.html#operator-associativity",
    "title": "Types",
    "section": "Operator Associativity",
    "text": "Operator Associativity\n// Assignment has right-to-left associativity\nint b;\nint a = b = 1; // b=1, then a=1\n\n// Comma operator has left-to-right associativity\nint x = (1, 2, 3);  // x=3 (last value)\nint y = (b = 2, 4); // b=2, y=4",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#c-style-cast",
    "href": "docs/core/types.html#c-style-cast",
    "title": "Types",
    "section": "C-Style Cast",
    "text": "C-Style Cast\n// Old style (avoid)\nint a = 5;\nfloat f = (float)a;\n\n// Prefer static_cast\nfloat f2 = static_cast&lt;float&gt;(a);\n\n// Note: static_cast cannot cast pointer to integer\n// int v = static_cast&lt;int&gt;(ptr); // error\nauto addr = reinterpret_cast&lt;std::size_t&gt;(ptr); // use reinterpret_cast",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#key-points",
    "href": "docs/core/types.html#key-points",
    "title": "Types",
    "section": "Key Points",
    "text": "Key Points\n\nFundamental types: arithmetic types + void + std::nullptr_t\nCompound types: everything built from fundamental types\nUse nullptr instead of NULL or 0 for null pointers\nIntegral promotion prevents overflow for small types\nPrefer static_cast over C-style casts\nAssignment is right-to-left, comma is left-to-right",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/types.html#see-also",
    "href": "docs/core/types.html#see-also",
    "title": "Types",
    "section": "See Also",
    "text": "See Also\n\nconst - const qualifier\ninitialization - variable initialization",
    "crumbs": [
      "Core",
      "Types"
    ]
  },
  {
    "objectID": "docs/core/structs.html",
    "href": "docs/core/structs.html",
    "title": "Structures",
    "section": "",
    "text": "Aggregate types grouping related data.",
    "crumbs": [
      "Core",
      "Structures"
    ]
  },
  {
    "objectID": "docs/core/structs.html#basic-struct",
    "href": "docs/core/structs.html#basic-struct",
    "title": "Structures",
    "section": "Basic Struct",
    "text": "Basic Struct\nstruct Foo {\n    int a;\n    int b;\n};\n\nFoo foo{1, 2}; // aggregate initialization",
    "crumbs": [
      "Core",
      "Structures"
    ]
  },
  {
    "objectID": "docs/core/structs.html#anonymous-struct",
    "href": "docs/core/structs.html#anonymous-struct",
    "title": "Structures",
    "section": "Anonymous Struct",
    "text": "Anonymous Struct\n// Named variable with unnamed type\nstruct {\n    int c;\n    int d;\n} Bar;\n\nBar.c = 1;\nNote: C++ doesn’t allow truly anonymous structs (C11 does).",
    "crumbs": [
      "Core",
      "Structures"
    ]
  },
  {
    "objectID": "docs/core/structs.html#structured-bindings-c17",
    "href": "docs/core/structs.html#structured-bindings-c17",
    "title": "Structures",
    "section": "Structured Bindings (C++17)",
    "text": "Structured Bindings (C++17)\nFoo get_foo() { return {1, 2}; }\n\nvoid example() {\n    Foo foo{1, 2};\n    auto [a, b] = foo;          // copy\n    auto& [x, y] = foo;         // reference\n    auto [c, d] = get_foo();    // from return value\n\n    int arr[2] = {1, 2};\n    auto& [p, q] = arr;         // works with arrays too\n}",
    "crumbs": [
      "Core",
      "Structures"
    ]
  },
  {
    "objectID": "docs/core/structs.html#struct-vs-class",
    "href": "docs/core/structs.html#struct-vs-class",
    "title": "Structures",
    "section": "Struct vs Class",
    "text": "Struct vs Class\nIn C++, struct and class are nearly identical: - struct: members default to public - class: members default to private\nstruct S { int x; };  // x is public\nclass C { int x; };   // x is private",
    "crumbs": [
      "Core",
      "Structures"
    ]
  },
  {
    "objectID": "docs/core/structs.html#key-points",
    "href": "docs/core/structs.html#key-points",
    "title": "Structures",
    "section": "Key Points",
    "text": "Key Points\n\nStructs are aggregates when they have no user-declared constructors\nAggregate initialization uses braces\nStructured bindings decompose structs into named variables\nPrefer struct for plain data, class for types with invariants",
    "crumbs": [
      "Core",
      "Structures"
    ]
  },
  {
    "objectID": "docs/core/structs.html#see-also",
    "href": "docs/core/structs.html#see-also",
    "title": "Structures",
    "section": "See Also",
    "text": "See Also\n\nbitfields - packed bit-level fields\nunions - overlapping storage\nclasses - full class features",
    "crumbs": [
      "Core",
      "Structures"
    ]
  },
  {
    "objectID": "docs/core/volatile.html",
    "href": "docs/core/volatile.html",
    "title": "volatile",
    "section": "",
    "text": "Tells the compiler to avoid aggressive memory optimizations for a variable.",
    "crumbs": [
      "Core",
      "volatile"
    ]
  },
  {
    "objectID": "docs/core/volatile.html#when-to-use",
    "href": "docs/core/volatile.html#when-to-use",
    "title": "volatile",
    "section": "When to Use",
    "text": "When to Use\n\nMemory-mapped hardware registers\nVariables modified by signal handlers\nVariables accessed by multiple threads (though prefer std::atomic)",
    "crumbs": [
      "Core",
      "volatile"
    ]
  },
  {
    "objectID": "docs/core/volatile.html#example-memory-mapped-register",
    "href": "docs/core/volatile.html#example-memory-mapped-register",
    "title": "volatile",
    "section": "Example: Memory-Mapped Register",
    "text": "Example: Memory-Mapped Register\n// Without volatile - compiler may optimize away the loop\nint* ptr1 = (int*)0x1234;\nwhile (*ptr1 == 0) { } // May become infinite loop!\n\n// With volatile - forces memory read each iteration\nvolatile int* ptr2 = (volatile int*)0x1234;\nwhile (*ptr2 == 0) { } // Actually reads from memory\nThe compiler might optimize the first loop by reading *ptr1 once and caching it in a register, never seeing external changes.",
    "crumbs": [
      "Core",
      "volatile"
    ]
  },
  {
    "objectID": "docs/core/volatile.html#example-out-of-bounds-access",
    "href": "docs/core/volatile.html#example-out-of-bounds-access",
    "title": "volatile",
    "section": "Example: Out-of-Bounds Access",
    "text": "Example: Out-of-Bounds Access\n// Without volatile - UB, compiler may remove entirely with -O1\nint arr[5];\narr[5] = 10; // May be optimized away\n\n// With volatile - generates the actual memory access\nvolatile int arr2[5];\narr2[5] = 10; // Code generated (will likely crash)",
    "crumbs": [
      "Core",
      "volatile"
    ]
  },
  {
    "objectID": "docs/core/volatile.html#key-points",
    "href": "docs/core/volatile.html#key-points",
    "title": "volatile",
    "section": "Key Points",
    "text": "Key Points\n\nvolatile prevents optimization, not thread-safety\nUse std::atomic for thread-safe access\nCommon in embedded/systems programming\nCan combine with const: const volatile int*",
    "crumbs": [
      "Core",
      "volatile"
    ]
  },
  {
    "objectID": "docs/core/volatile.html#see-also",
    "href": "docs/core/volatile.html#see-also",
    "title": "volatile",
    "section": "See Also",
    "text": "See Also\n\nconst - const qualifier\nmemory-order - memory ordering for atomics",
    "crumbs": [
      "Core",
      "volatile"
    ]
  },
  {
    "objectID": "docs/core/unions.html",
    "href": "docs/core/unions.html",
    "title": "Unions",
    "section": "",
    "text": "Overlapping storage where all members share the same memory location.",
    "crumbs": [
      "Core",
      "Unions"
    ]
  },
  {
    "objectID": "docs/core/unions.html#basic-usage",
    "href": "docs/core/unions.html#basic-usage",
    "title": "Unions",
    "section": "Basic Usage",
    "text": "Basic Usage\nunion Data {\n    int i;\n    float f;\n};\n\nData d;\nd.i = 42;       // write as int\nd.f = 3.14f;    // overwrites, now contains float\n// d.i is now garbage (reading inactive member is UB)",
    "crumbs": [
      "Core",
      "Unions"
    ]
  },
  {
    "objectID": "docs/core/unions.html#size",
    "href": "docs/core/unions.html#size",
    "title": "Unions",
    "section": "Size",
    "text": "Size\nUnion size equals its largest member:\nunion Example {\n    char c;      // 1 byte\n    int i;       // 4 bytes\n    double d;    // 8 bytes\n}; // sizeof(Example) == 8",
    "crumbs": [
      "Core",
      "Unions"
    ]
  },
  {
    "objectID": "docs/core/unions.html#type-punning-caution",
    "href": "docs/core/unions.html#type-punning-caution",
    "title": "Unions",
    "section": "Type Punning (Caution!)",
    "text": "Type Punning (Caution!)\nunion Bits {\n    float f;\n    uint32_t i;\n};\n\nBits b;\nb.f = 1.0f;\n// Reading b.i is technically UB in C++\n// (though often works in practice)\nFor safe type punning, use std::bit_cast (C++20) or memcpy.",
    "crumbs": [
      "Core",
      "Unions"
    ]
  },
  {
    "objectID": "docs/core/unions.html#key-points",
    "href": "docs/core/unions.html#key-points",
    "title": "Unions",
    "section": "Key Points",
    "text": "Key Points\n\nAll members share the same memory address\nOnly one member is “active” at a time\nReading inactive member is undefined behavior\nSize equals largest member (plus padding)\nPrefer std::variant (C++17) for type-safe unions",
    "crumbs": [
      "Core",
      "Unions"
    ]
  },
  {
    "objectID": "docs/core/unions.html#see-also",
    "href": "docs/core/unions.html#see-also",
    "title": "Unions",
    "section": "See Also",
    "text": "See Also\n\nstructs - non-overlapping storage\nvariant - type-safe discriminated union",
    "crumbs": [
      "Core",
      "Unions"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html",
    "href": "docs/core/namespaces.html",
    "title": "Namespaces",
    "section": "",
    "text": "Organize code and prevent name collisions.",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html#nested-namespaces-c17",
    "href": "docs/core/namespaces.html#nested-namespaces-c17",
    "title": "Namespaces",
    "section": "Nested Namespaces (C++17)",
    "text": "Nested Namespaces (C++17)\n// Before C++17\nnamespace n1 { namespace n2 { namespace n3 {\n    struct A {};\n}}}\n\n// C++17 and later\nnamespace n1::n2::n3 {\n    struct A {};\n}",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html#namespace-alias",
    "href": "docs/core/namespaces.html#namespace-alias",
    "title": "Namespaces",
    "section": "Namespace Alias",
    "text": "Namespace Alias\nnamespace n = n1::n2::n3;\nn::A obj;",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html#anonymous-namespace",
    "href": "docs/core/namespaces.html#anonymous-namespace",
    "title": "Namespaces",
    "section": "Anonymous Namespace",
    "text": "Anonymous Namespace\nEverything inside has internal linkage (file-local):\nnamespace {\n    int x = 0;  // only visible in this translation unit\n}\n// Preferred over 'static' for file-local declarations",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html#inline-namespace",
    "href": "docs/core/namespaces.html#inline-namespace",
    "title": "Namespaces",
    "section": "Inline Namespace",
    "text": "Inline Namespace\nMembers appear in parent namespace (useful for versioning):\nnamespace Library {\n\ninline namespace V2 {\n    void func() { /* V2 implementation */ }\n}\n\nnamespace V1 {\n    void func() { /* V1 implementation */ }\n}\n\n} // namespace Library\n\nLibrary::func();     // calls V2::func (inline is default)\nLibrary::V1::func(); // explicitly calls V1\nLibrary::V2::func(); // explicitly calls V2",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html#deprecated-namespace-c17",
    "href": "docs/core/namespaces.html#deprecated-namespace-c17",
    "title": "Namespaces",
    "section": "Deprecated Namespace (C++17)",
    "text": "Deprecated Namespace (C++17)\nnamespace [[deprecated]] OldAPI {\n    // Using this namespace produces a warning\n}",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html#key-points",
    "href": "docs/core/namespaces.html#key-points",
    "title": "Namespaces",
    "section": "Key Points",
    "text": "Key Points\n\nUse namespaces to avoid name collisions\nNested namespace syntax a::b::c requires C++17\nAnonymous namespaces replace static for internal linkage\nInline namespaces enable API versioning\nCan apply attributes to namespaces",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/namespaces.html#see-also",
    "href": "docs/core/namespaces.html#see-also",
    "title": "Namespaces",
    "section": "See Also",
    "text": "See Also\n\nattributes - [[deprecated]] and other attributes",
    "crumbs": [
      "Core",
      "Namespaces"
    ]
  },
  {
    "objectID": "docs/core/attributes.html",
    "href": "docs/core/attributes.html",
    "title": "Attributes",
    "section": "",
    "text": "Compiler hints and metadata using [[attribute]] syntax.",
    "crumbs": [
      "Core",
      "Attributes"
    ]
  },
  {
    "objectID": "docs/core/attributes.html#standard-attributes",
    "href": "docs/core/attributes.html#standard-attributes",
    "title": "Attributes",
    "section": "Standard Attributes",
    "text": "Standard Attributes\n\n[[noreturn]]\nFunction never returns (throws, terminates, or loops forever):\n[[noreturn]] void fatal_error() {\n    throw std::runtime_error(\"fatal\");\n}\n\n\n[[deprecated]] (C++14)\nMark as deprecated with optional message:\n[[deprecated(\"use new_function() instead\")]]\nvoid old_function() { }\n\n\n[[nodiscard]] (C++17)\nWarn if return value is ignored:\n[[nodiscard]] int* allocate() {\n    return new int;\n}\n\nallocate(); // warning: ignoring return value\n\n\n[[maybe_unused]]\nSuppress unused warnings:\n[[maybe_unused]] void debug_only() { }\n[[maybe_unused]] int x = compute();\n\n\n[[fallthrough]] (C++17)\nIndicate intentional fallthrough in switch:\nswitch (x) {\ncase 1:\n    do_something();\n    [[fallthrough]];\ncase 2:\n    do_more(); // no warning about fallthrough\n    break;\n}",
    "crumbs": [
      "Core",
      "Attributes"
    ]
  },
  {
    "objectID": "docs/core/attributes.html#key-points",
    "href": "docs/core/attributes.html#key-points",
    "title": "Attributes",
    "section": "Key Points",
    "text": "Key Points\n\nAttributes provide hints to compiler and tools\nStandard attributes are portable across compilers\nCompilers may define additional attributes\nUse [[nodiscard]] for functions returning allocated memory or error codes\nUse [[deprecated]] to guide users away from old APIs",
    "crumbs": [
      "Core",
      "Attributes"
    ]
  },
  {
    "objectID": "docs/core/attributes.html#see-also",
    "href": "docs/core/attributes.html#see-also",
    "title": "Attributes",
    "section": "See Also",
    "text": "See Also\n\nenums - attributes on enum values\nnamespaces - deprecated namespaces",
    "crumbs": [
      "Core",
      "Attributes"
    ]
  },
  {
    "objectID": "docs/core/bitfields.html",
    "href": "docs/core/bitfields.html",
    "title": "Bit Fields",
    "section": "",
    "text": "Variables with predefined bit widths within a struct.",
    "crumbs": [
      "Core",
      "Bit Fields"
    ]
  },
  {
    "objectID": "docs/core/bitfields.html#basic-usage",
    "href": "docs/core/bitfields.html#basic-usage",
    "title": "Bit Fields",
    "section": "Basic Usage",
    "text": "Basic Usage\nstruct Foo {\n    unsigned int b1 : 10; // 10 bits [0, 1023]\n    unsigned int b2 : 10; // 10 bits [0, 1023]\n    unsigned int b3 : 8;  // 8 bits  [0, 255]\n}; // sizeof(Foo) == 4 bytes (packed into 28 bits)",
    "crumbs": [
      "Core",
      "Bit Fields"
    ]
  },
  {
    "objectID": "docs/core/bitfields.html#padding-and-alignment",
    "href": "docs/core/bitfields.html#padding-and-alignment",
    "title": "Bit Fields",
    "section": "Padding and Alignment",
    "text": "Padding and Alignment\nstruct Bar {\n    unsigned int b1 : 10; // 10 bits\n    unsigned int : 0;     // force alignment to next unit\n    unsigned int b2 : 10; // 10 bits (starts new unit)\n    unsigned int : 6;     // skip 6 bits\n    unsigned int b3 : 10; // 10 bits\n}; // sizeof(Bar) == 8 bytes",
    "crumbs": [
      "Core",
      "Bit Fields"
    ]
  },
  {
    "objectID": "docs/core/bitfields.html#mixed-types",
    "href": "docs/core/bitfields.html#mixed-types",
    "title": "Bit Fields",
    "section": "Mixed Types",
    "text": "Mixed Types\nstruct Baz {\n    unsigned char b1 : 3;\n    unsigned char : 2;    // 2-bit padding\n    unsigned char b2 : 6;\n    unsigned char b3 : 2;\n}; // sizeof(Baz) == 2 bytes",
    "crumbs": [
      "Core",
      "Bit Fields"
    ]
  },
  {
    "objectID": "docs/core/bitfields.html#key-points",
    "href": "docs/core/bitfields.html#key-points",
    "title": "Bit Fields",
    "section": "Key Points",
    "text": "Key Points\n\nBit width cannot exceed underlying type size\nAnonymous bit fields create padding\n: 0 forces alignment to next storage unit\nActual layout is implementation-defined\nCannot take address of bit field members\nUseful for hardware registers, protocols, memory optimization",
    "crumbs": [
      "Core",
      "Bit Fields"
    ]
  },
  {
    "objectID": "docs/core/bitfields.html#see-also",
    "href": "docs/core/bitfields.html#see-also",
    "title": "Bit Fields",
    "section": "See Also",
    "text": "See Also\n\nstructs - basic structures\nunions - overlapping storage",
    "crumbs": [
      "Core",
      "Bit Fields"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html",
    "href": "docs/thirdparty/fmt.html",
    "title": "fmt",
    "section": "",
    "text": "Modern formatting library (basis for C++20 std::format).",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#basic-formatting",
    "href": "docs/thirdparty/fmt.html#basic-formatting",
    "title": "fmt",
    "section": "Basic Formatting",
    "text": "Basic Formatting\n#include &lt;fmt/core.h&gt;\n\nstd::string msg = fmt::format(\"The answer is {}\", 42);\nstd::string msg2 = fmt::format(\"{1} {0}!\", \"world\", \"Hello\");\n\nfmt::print(\"{}, {}\\n\", msg, msg2);\nfmt::print(stderr, \"Don't forget to flush the buffer\\n\");",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#custom-formatter",
    "href": "docs/thirdparty/fmt.html#custom-formatter",
    "title": "fmt",
    "section": "Custom Formatter",
    "text": "Custom Formatter\n#include &lt;fmt/format.h&gt;\n\nstruct foo {\n    int x = 1;\n    int y = 2;\n};\n\ntemplate &lt;&gt;\nstruct fmt::formatter&lt;foo&gt; : fmt::formatter&lt;std::string&gt; {\n    auto format(const foo &f, fmt::format_context &ctx) {\n        return fmt::formatter&lt;std::string&gt;::format(\n            fmt::format(\"({}, {})\", f.x, f.y), ctx);\n    }\n};\n\nfoo f;\nfmt::print(\"foo: {}\\n\", f);  // foo: (1, 2)",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#pointers-and-enums",
    "href": "docs/thirdparty/fmt.html#pointers-and-enums",
    "title": "fmt",
    "section": "Pointers and Enums",
    "text": "Pointers and Enums\nint x = 42;\nvoid *p = &x;\nfmt::print(\"Pointer: {:p} {}\\n\", p, fmt::ptr(p));\n\nenum class Color : uint8_t { RED, GREEN, BLUE };\nColor c = Color::RED;\nfmt::print(\"Color: {}\\n\", fmt::underlying(c));  // Color: 0",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#chrono-formatting",
    "href": "docs/thirdparty/fmt.html#chrono-formatting",
    "title": "fmt",
    "section": "Chrono Formatting",
    "text": "Chrono Formatting\n#include &lt;fmt/chrono.h&gt;\n\nauto now = std::chrono::system_clock::now();\nfmt::print(\"The date is {}\\n\", fmt::format(\"{:%Y-%m-%d %H:%M:%S}\", now));",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#range-formatting",
    "href": "docs/thirdparty/fmt.html#range-formatting",
    "title": "fmt",
    "section": "Range Formatting",
    "text": "Range Formatting\n#include &lt;fmt/ranges.h&gt;\n\nstd::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\nfmt::print(\"{}\\n\", v);                    // [1, 2, 3, 4, 5]\nfmt::print(\"[{}]\\n\", fmt::join(v, \"/ \")); // [1/ 2/ 3/ 4/ 5]",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#color-output",
    "href": "docs/thirdparty/fmt.html#color-output",
    "title": "fmt",
    "section": "Color Output",
    "text": "Color Output\n#include &lt;fmt/color.h&gt;\n\nfmt::print(fg(fmt::color::crimson) | bg(fmt::color::floral_white) |\n               fmt::emphasis::italic,\n           \"Crimson text on floral white\\n\");",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#headers",
    "href": "docs/thirdparty/fmt.html#headers",
    "title": "fmt",
    "section": "Headers",
    "text": "Headers\n\n\n\nHeader\nFeatures\n\n\n\n\nfmt/core.h\nformat, print (minimal)\n\n\nfmt/format.h\nFull formatting, custom formatters\n\n\nfmt/ranges.h\nContainer and range formatting\n\n\nfmt/chrono.h\nDate/time formatting\n\n\nfmt/color.h\nTerminal colors and styles",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#key-points",
    "href": "docs/thirdparty/fmt.html#key-points",
    "title": "fmt",
    "section": "Key Points",
    "text": "Key Points\n\nFaster than iostreams and printf\nType-safe formatting\nBasis for C++20 std::format\nExtensible via custom formatters\nHeader-only or compiled modes",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/thirdparty/fmt.html#see-also",
    "href": "docs/thirdparty/fmt.html#see-also",
    "title": "fmt",
    "section": "See Also",
    "text": "See Also\n\nio - standard I/O streams\nchrono - time utilities",
    "crumbs": [
      "Third-Party",
      "fmt"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html",
    "href": "docs/stdlib/chrono.html",
    "title": "std::chrono",
    "section": "",
    "text": "Time utilities and clocks.",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html#time-types",
    "href": "docs/stdlib/chrono.html#time-types",
    "title": "std::chrono",
    "section": "Time Types",
    "text": "Time Types\n\nWall-clock time: Real-world elapsed time\nCPU time: Time spent executing on CPU\nSystem time: Time spent in kernel (syscalls, I/O)",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html#clocks",
    "href": "docs/stdlib/chrono.html#clocks",
    "title": "std::chrono",
    "section": "Clocks",
    "text": "Clocks\n#include &lt;chrono&gt;\nusing namespace std::chrono;\n\n// system_clock: wall-clock, can be adjusted\nauto t1 = system_clock::now();\n\n// steady_clock: monotonic, for measuring durations\nauto t2 = steady_clock::now();\n\n// high_resolution_clock: highest precision available\nauto t3 = high_resolution_clock::now();",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html#measuring-duration",
    "href": "docs/stdlib/chrono.html#measuring-duration",
    "title": "std::chrono",
    "section": "Measuring Duration",
    "text": "Measuring Duration\nusing namespace std::chrono;\n\nauto start = steady_clock::now();\n// ... work ...\nauto end = steady_clock::now();\n\nduration&lt;double&gt; diff = end - start;\nauto ms = duration_cast&lt;milliseconds&gt;(diff);\nauto us = duration_cast&lt;microseconds&gt;(diff);",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html#duration-literals-c14",
    "href": "docs/stdlib/chrono.html#duration-literals-c14",
    "title": "std::chrono",
    "section": "Duration Literals (C++14)",
    "text": "Duration Literals (C++14)\nusing namespace std::chrono_literals;\n\nauto hour = 1h;\nauto minute = 30min;\nauto second = 45s;\nauto milli = 100ms;\nauto micro = 500us;\nauto nano = 1000ns;",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html#cpu-time-c-style",
    "href": "docs/stdlib/chrono.html#cpu-time-c-style",
    "title": "std::chrono",
    "section": "CPU Time (C-style)",
    "text": "CPU Time (C-style)\n#include &lt;ctime&gt;\n\nclock_t start = std::clock();\n// ... work ...\nclock_t end = std::clock();\n\ndouble cpu_time = double(end - start) / CLOCKS_PER_SEC;",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html#key-points",
    "href": "docs/stdlib/chrono.html#key-points",
    "title": "std::chrono",
    "section": "Key Points",
    "text": "Key Points\n\nUse steady_clock for measuring durations (monotonic)\nUse system_clock for wall-clock time\nDuration literals make code readable\nduration_cast for conversions\nC++20 adds calendar and time zone support",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/chrono.html#see-also",
    "href": "docs/stdlib/chrono.html#see-also",
    "title": "std::chrono",
    "section": "See Also",
    "text": "See Also\n\nthreads - sleep_for uses chrono",
    "crumbs": [
      "Standard Library",
      "std::chrono"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html",
    "href": "docs/stdlib/io.html",
    "title": "I/O Streams",
    "section": "",
    "text": "Input/output operations.",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html#standard-streams",
    "href": "docs/stdlib/io.html#standard-streams",
    "title": "I/O Streams",
    "section": "Standard Streams",
    "text": "Standard Streams\n#include &lt;iostream&gt;\n\nint x;\nstd::cin &gt;&gt; x;              // buffered stdin\n\nstd::cout &lt;&lt; x &lt;&lt; '\\n';     // buffered stdout\nstd::cerr &lt;&lt; \"Error\\n\";     // unbuffered stderr\nstd::clog &lt;&lt; \"Log\\n\";       // buffered stderr",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html#formatting",
    "href": "docs/stdlib/io.html#formatting",
    "title": "I/O Streams",
    "section": "Formatting",
    "text": "Formatting\n#include &lt;iomanip&gt;\n\n// Integer bases\nstd::cout &lt;&lt; std::dec &lt;&lt; 10;  // decimal: 10\nstd::cout &lt;&lt; std::hex &lt;&lt; 10;  // hex: a\nstd::cout &lt;&lt; std::oct &lt;&lt; 10;  // octal: 12\n\n// Boolean\nstd::cout &lt;&lt; std::boolalpha &lt;&lt; true;   // \"true\"\nstd::cout &lt;&lt; std::noboolalpha &lt;&lt; true; // \"1\"\n\n// Floating point\nstd::cout &lt;&lt; std::setprecision(2) &lt;&lt; std::fixed &lt;&lt; 3.14159;      // 3.14\nstd::cout &lt;&lt; std::setprecision(2) &lt;&lt; std::scientific &lt;&lt; 3.14159; // 3.14e+00\n\n// Alignment\nstd::cout &lt;&lt; std::left &lt;&lt; std::setw(10) &lt;&lt; \"left\";\nstd::cout &lt;&lt; std::right &lt;&lt; std::setw(10) &lt;&lt; \"right\";\n\n// Quoted strings\nstd::cout &lt;&lt; std::quoted(\"hello\");  // \"hello\"",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html#file-io",
    "href": "docs/stdlib/io.html#file-io",
    "title": "I/O Streams",
    "section": "File I/O",
    "text": "File I/O\n#include &lt;fstream&gt;\n\n// Reading\nstd::ifstream in(\"input.txt\");\nstd::string line;\nwhile (std::getline(in, line)) {\n    // process line\n}\n\n// Writing\nstd::ofstream out(\"output.txt\", std::ios::app);\nout &lt;&lt; \"content\\n\";\n\n// Error handling\nif (!in.is_open()) {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; std::strerror(errno) &lt;&lt; '\\n';\n}\nif (in.bad()) {\n    // I/O error occurred\n}",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html#stream-manipulation",
    "href": "docs/stdlib/io.html#stream-manipulation",
    "title": "I/O Streams",
    "section": "Stream Manipulation",
    "text": "Stream Manipulation\nchar c = in.peek();   // peek next char\nchar c = in.get();    // get and advance\n\nauto pos = in.tellg();  // get position (g = get)\nin.seekg(0);            // seek to beginning\n\nout.tellp();            // put position\nout.seekp(0);           // seek for writing\n\nin.ignore(100, '\\n');   // skip until delimiter\nin.clear();             // clear error flags",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html#flushing",
    "href": "docs/stdlib/io.html#flushing",
    "title": "I/O Streams",
    "section": "Flushing",
    "text": "Flushing\n// flush forces output to device (slow)\nstd::cout &lt;&lt; std::flush;\nstd::cout &lt;&lt; '\\n' &lt;&lt; std::flush; // same as std::endl\nPrefer '\\n' over std::endl for performance.",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html#key-points",
    "href": "docs/stdlib/io.html#key-points",
    "title": "I/O Streams",
    "section": "Key Points",
    "text": "Key Points\n\ncerr is unbuffered (immediate output)\nendl flushes, '\\n' doesn’t\nCheck is_open(), bad(), fail() for errors\nUse &lt;iomanip&gt; for formatting\nFile streams auto-close in destructor (RAII)",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/io.html#see-also",
    "href": "docs/stdlib/io.html#see-also",
    "title": "I/O Streams",
    "section": "See Also",
    "text": "See Also\n\nfilesystem - file operations",
    "crumbs": [
      "Standard Library",
      "I/O Streams"
    ]
  },
  {
    "objectID": "docs/stdlib/any.html",
    "href": "docs/stdlib/any.html",
    "title": "std::any",
    "section": "",
    "text": "Type-erased container for any single value.",
    "crumbs": [
      "Standard Library",
      "std::any"
    ]
  },
  {
    "objectID": "docs/stdlib/any.html#basic-usage",
    "href": "docs/stdlib/any.html#basic-usage",
    "title": "std::any",
    "section": "Basic Usage",
    "text": "Basic Usage\n#include &lt;any&gt;\n#include &lt;string&gt;\n\nstd::any a = 42;\na = std::string{\"Hello\"};\na = 3.14;",
    "crumbs": [
      "Standard Library",
      "std::any"
    ]
  },
  {
    "objectID": "docs/stdlib/any.html#accessing-values",
    "href": "docs/stdlib/any.html#accessing-values",
    "title": "std::any",
    "section": "Accessing Values",
    "text": "Accessing Values\nstd::any a = std::string{\"Hello\"};\n\n// Check type\nif (a.type() == typeid(std::string)) {\n    std::string s = std::any_cast&lt;std::string&gt;(a);\n}\n\n// any_cast throws std::bad_any_cast if wrong type\ntry {\n    int x = std::any_cast&lt;int&gt;(a);\n} catch (std::bad_any_cast&) { }\n\n// Pointer version returns nullptr if wrong type\nif (auto* p = std::any_cast&lt;std::string&gt;(&a)) {\n    // *p is the string\n}",
    "crumbs": [
      "Standard Library",
      "std::any"
    ]
  },
  {
    "objectID": "docs/stdlib/any.html#checking-state",
    "href": "docs/stdlib/any.html#checking-state",
    "title": "std::any",
    "section": "Checking State",
    "text": "Checking State\nstd::any a = 42;\n\na.has_value();  // true\na.type();       // typeid(int)\n\na.reset();      // clear\na.has_value();  // false",
    "crumbs": [
      "Standard Library",
      "std::any"
    ]
  },
  {
    "objectID": "docs/stdlib/any.html#key-points",
    "href": "docs/stdlib/any.html#key-points",
    "title": "std::any",
    "section": "Key Points",
    "text": "Key Points\n\nHolds any copyable type\nUses type erasure (heap allocation for large types)\nRuntime type checking via type() and any_cast\nLess efficient than variant (no compile-time type info)\nUse when types are truly unknown at compile time",
    "crumbs": [
      "Standard Library",
      "std::any"
    ]
  },
  {
    "objectID": "docs/stdlib/any.html#comparison",
    "href": "docs/stdlib/any.html#comparison",
    "title": "std::any",
    "section": "Comparison",
    "text": "Comparison\n\n\n\nFeature\noptional\nvariant\nany\n\n\n\n\nTypes\n1 or none\nfixed set\nany\n\n\nType safety\ncompile-time\ncompile-time\nruntime\n\n\nOverhead\nminimal\nminimal\nheap possible",
    "crumbs": [
      "Standard Library",
      "std::any"
    ]
  },
  {
    "objectID": "docs/stdlib/any.html#see-also",
    "href": "docs/stdlib/any.html#see-also",
    "title": "std::any",
    "section": "See Also",
    "text": "See Also\n\noptional - nullable single type\nvariant - known set of types",
    "crumbs": [
      "Standard Library",
      "std::any"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/array.html",
    "href": "docs/stdlib/containers/array.html",
    "title": "std::array",
    "section": "",
    "text": "Fixed-size array with STL interface.",
    "crumbs": [
      "Standard Library",
      "std::array"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/array.html#basic-usage",
    "href": "docs/stdlib/containers/array.html#basic-usage",
    "title": "std::array",
    "section": "Basic Usage",
    "text": "Basic Usage\n#include &lt;array&gt;\n\nstd::array&lt;int, 5&gt; arr = {1, 2, 3, 4, 5};\n\narr[0] = 10;           // no bounds checking\narr.at(0) = 10;        // with bounds checking\n\narr.front();           // first element\narr.back();            // last element\narr.data();            // raw pointer\n\narr.size();            // 5\narr.empty();           // false\narr.fill(0);           // set all to 0",
    "crumbs": [
      "Standard Library",
      "std::array"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/array.html#d-matrix",
    "href": "docs/stdlib/containers/array.html#d-matrix",
    "title": "std::array",
    "section": "2D Matrix",
    "text": "2D Matrix\ntemplate &lt;typename T, size_t Row, size_t Col&gt;\nusing Matrix = std::array&lt;std::array&lt;T, Col&gt;, Row&gt;;\n\nMatrix&lt;int, 2, 3&gt; mat = {{{1, 2, 3}, {4, 5, 6}}};\nmat[0][1] = 10;",
    "crumbs": [
      "Standard Library",
      "std::array"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/array.html#n-dimensional-array",
    "href": "docs/stdlib/containers/array.html#n-dimensional-array",
    "title": "std::array",
    "section": "N-Dimensional Array",
    "text": "N-Dimensional Array\ntemplate &lt;typename T, size_t Dim, size_t... Dims&gt;\nstruct MultiDimArray {\n    using type = std::array&lt;typename MultiDimArray&lt;T, Dims...&gt;::type, Dim&gt;;\n};\n\ntemplate &lt;typename T, size_t Dim&gt;\nstruct MultiDimArray&lt;T, Dim&gt; {\n    using type = std::array&lt;T, Dim&gt;;\n};\n\ntemplate &lt;typename T, size_t... Dims&gt;\nusing Array = typename MultiDimArray&lt;T, Dims...&gt;::type;\n\nArray&lt;int, 2, 3, 4&gt; arr3d; // int[2][3][4]",
    "crumbs": [
      "Standard Library",
      "std::array"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/array.html#key-points",
    "href": "docs/stdlib/containers/array.html#key-points",
    "title": "std::array",
    "section": "Key Points",
    "text": "Key Points\n\nSize known at compile time (part of the type)\nNo heap allocation\nCompatible with STL algorithms\nPrefer over C-style arrays\nUse std::vector for dynamic sizes",
    "crumbs": [
      "Standard Library",
      "std::array"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/array.html#see-also",
    "href": "docs/stdlib/containers/array.html#see-also",
    "title": "std::array",
    "section": "See Also",
    "text": "See Also\n\nstring - dynamic string",
    "crumbs": [
      "Standard Library",
      "std::array"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html",
    "href": "docs/stdlib/random.html",
    "title": "Random Numbers",
    "section": "",
    "text": "Modern random number generation.",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html#basic-pattern",
    "href": "docs/stdlib/random.html#basic-pattern",
    "title": "Random Numbers",
    "section": "Basic Pattern",
    "text": "Basic Pattern\n#include &lt;random&gt;\n\n// 1. Seed source\nstd::random_device rd;\n\n// 2. Random engine\nstd::mt19937 gen(rd());\n\n// 3. Distribution\nstd::uniform_int_distribution&lt;int&gt; dist(1, 100);\n\n// 4. Generate\nint value = dist(gen);",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html#seed-sources",
    "href": "docs/stdlib/random.html#seed-sources",
    "title": "Random Numbers",
    "section": "Seed Sources",
    "text": "Seed Sources\nstd::random_device rd;  // hardware entropy (best)\n\n// Seed sequence for better initialization\nstd::seed_seq seq{rd(), rd(), rd(), rd()};\nstd::mt19937 gen(seq);",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html#engines",
    "href": "docs/stdlib/random.html#engines",
    "title": "Random Numbers",
    "section": "Engines",
    "text": "Engines\n// Linear congruential (fast, lower quality)\nstd::minstd_rand gen1(rd());\n\n// Mersenne Twister (good balance)\nstd::mt19937 gen2(rd());       // 32-bit\nstd::mt19937_64 gen3(rd());    // 64-bit\n\n// Subtract with carry (highest quality, slowest)\nstd::ranlux24 gen4(rd());\nstd::ranlux48 gen5(rd());",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html#distributions",
    "href": "docs/stdlib/random.html#distributions",
    "title": "Random Numbers",
    "section": "Distributions",
    "text": "Distributions\n// Uniform\nstd::uniform_int_distribution&lt;int&gt; d1(0, 100);\nstd::uniform_real_distribution&lt;double&gt; d2(0.0, 1.0);\n\n// Normal (Gaussian)\nstd::normal_distribution&lt;double&gt; d3(mean, stddev);\n\n// Bernoulli (coin flip)\nstd::bernoulli_distribution d4(0.5);  // 50% true\n\n// Poisson\nstd::poisson_distribution&lt;int&gt; d5(lambda);\n\n// And many more...",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html#common-patterns",
    "href": "docs/stdlib/random.html#common-patterns",
    "title": "Random Numbers",
    "section": "Common Patterns",
    "text": "Common Patterns\n// Shuffle\nstd::vector&lt;int&gt; v{1, 2, 3, 4, 5};\nstd::shuffle(v.begin(), v.end(), gen);\n\n// Random element\nauto it = v.begin();\nstd::advance(it, dist(gen) % v.size());",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html#key-points",
    "href": "docs/stdlib/random.html#key-points",
    "title": "Random Numbers",
    "section": "Key Points",
    "text": "Key Points\n\nDon’t use rand() / srand() (poor quality)\nrandom_device for seeding, not generation\nmt19937 is the go-to engine\nMatch distribution to your needs\nCreate engine once, reuse",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/random.html#see-also",
    "href": "docs/stdlib/random.html#see-also",
    "title": "Random Numbers",
    "section": "See Also",
    "text": "See Also\n\nchrono - time-based seeds (avoid if possible)",
    "crumbs": [
      "Standard Library",
      "Random Numbers"
    ]
  },
  {
    "objectID": "docs/stdlib/variant.html",
    "href": "docs/stdlib/variant.html",
    "title": "std::variant",
    "section": "",
    "text": "Type-safe union.",
    "crumbs": [
      "Standard Library",
      "std::variant"
    ]
  },
  {
    "objectID": "docs/stdlib/variant.html#basic-usage",
    "href": "docs/stdlib/variant.html#basic-usage",
    "title": "std::variant",
    "section": "Basic Usage",
    "text": "Basic Usage\n#include &lt;variant&gt;\n\nstd::variant&lt;int, float, bool&gt; v = 3.3f;\n\n// Access by type\nfloat f = std::get&lt;float&gt;(v);\n\n// Access by index\nfloat f2 = std::get&lt;1&gt;(v);  // index 1 = float\n\n// Check current type\nint idx = v.index();  // 1 (float)\n\n// Modify\nstd::get&lt;bool&gt;(v) = true;\nv.index();  // now 2 (bool)",
    "crumbs": [
      "Standard Library",
      "std::variant"
    ]
  },
  {
    "objectID": "docs/stdlib/variant.html#safe-access",
    "href": "docs/stdlib/variant.html#safe-access",
    "title": "std::variant",
    "section": "Safe Access",
    "text": "Safe Access\n// get throws std::bad_variant_access if wrong type\ntry {\n    int x = std::get&lt;int&gt;(v);  // throws if not int\n} catch (std::bad_variant_access&) { }\n\n// get_if returns pointer (nullptr if wrong type)\nif (auto* p = std::get_if&lt;int&gt;(&v)) {\n    // *p is the int value\n}\n\n// holds_alternative\nif (std::holds_alternative&lt;int&gt;(v)) {\n    // v contains int\n}",
    "crumbs": [
      "Standard Library",
      "std::variant"
    ]
  },
  {
    "objectID": "docs/stdlib/variant.html#stdvisit",
    "href": "docs/stdlib/variant.html#stdvisit",
    "title": "std::variant",
    "section": "std::visit",
    "text": "std::visit\nApply a visitor to the current value:\nstd::variant&lt;int, float, bool&gt; v = 3.3f;\n\nstd::visit([](auto&& arg) {\n    using T = std::decay_t&lt;decltype(arg)&gt;;\n    if constexpr (std::is_same_v&lt;T, int&gt;) {\n        // handle int\n    } else if constexpr (std::is_same_v&lt;T, float&gt;) {\n        // handle float\n    } else if constexpr (std::is_same_v&lt;T, bool&gt;) {\n        // handle bool\n    }\n}, v);",
    "crumbs": [
      "Standard Library",
      "std::variant"
    ]
  },
  {
    "objectID": "docs/stdlib/variant.html#key-points",
    "href": "docs/stdlib/variant.html#key-points",
    "title": "std::variant",
    "section": "Key Points",
    "text": "Key Points\n\nType-safe alternative to union\nStores exactly one of the types at a time\nindex() returns which type is active\nstd::visit for type-safe access\nPrefer over raw unions",
    "crumbs": [
      "Standard Library",
      "std::variant"
    ]
  },
  {
    "objectID": "docs/stdlib/variant.html#see-also",
    "href": "docs/stdlib/variant.html#see-also",
    "title": "std::variant",
    "section": "See Also",
    "text": "See Also\n\noptional - nullable value\nany - any type (type-erased)",
    "crumbs": [
      "Standard Library",
      "std::variant"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html",
    "href": "docs/patterns/solid.html",
    "title": "SOLID Principles",
    "section": "",
    "text": "Five design principles for maintainable OOP code.",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html#s---single-responsibility-principle",
    "href": "docs/patterns/solid.html#s---single-responsibility-principle",
    "title": "SOLID Principles",
    "section": "S - Single Responsibility Principle",
    "text": "S - Single Responsibility Principle\nA class should have only one reason to change.\n// BAD: Journal handles both data and persistence\nstruct Journal {\n    std::vector&lt;std::string&gt; entries;\n    void add_entry(const std::string& entry);\n    void save(const std::string& filename);  // ❌ Not its job\n};\n\n// GOOD: Separate concerns\nstruct Journal {\n    std::vector&lt;std::string&gt; entries;\n    void add_entry(const std::string& entry);\n};\n\nstruct PersistenceManager {\n    static void save(const Journal& j, const std::string& filename);\n};",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html#o---openclosed-principle",
    "href": "docs/patterns/solid.html#o---openclosed-principle",
    "title": "SOLID Principles",
    "section": "O - Open/Closed Principle",
    "text": "O - Open/Closed Principle\nOpen for extension, closed for modification.\n// BAD: Adding filters requires modifying ProductFilter\nstruct ProductFilter {\n    std::vector&lt;Product*&gt; by_color(/*...*/);\n    std::vector&lt;Product*&gt; by_size(/*...*/);     // ❌ Had to modify\n    std::vector&lt;Product*&gt; by_color_and_size(/*...*/); // ❌ Again\n};\n\n// GOOD: Extend via new specifications\ntemplate &lt;typename T&gt;\nstruct Specification {\n    virtual bool is_satisfied(T* item) = 0;\n};\n\nstruct ColorSpec : Specification&lt;Product&gt; {\n    Color color;\n    bool is_satisfied(Product* p) override { return p-&gt;color == color; }\n};\n\nstruct SizeSpec : Specification&lt;Product&gt; { /* ... */ };\n\n// Combine specs without modifying existing code\nauto green_large = ColorSpec(Green) && SizeSpec(Large);",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html#l---liskov-substitution-principle",
    "href": "docs/patterns/solid.html#l---liskov-substitution-principle",
    "title": "SOLID Principles",
    "section": "L - Liskov Substitution Principle",
    "text": "L - Liskov Substitution Principle\nSubtypes must be substitutable for their base types.\n// BAD: Square violates Rectangle's contract\nclass Rectangle {\npublic:\n    virtual void set_width(int w) { width = w; }\n    virtual void set_height(int h) { height = h; }\n    int area() { return width * height; }\n};\n\nclass Square : public Rectangle {\n    void set_width(int w) override { width = height = w; }  // ❌\n    void set_height(int h) override { width = height = h; } // ❌\n};\n\nvoid process(Rectangle& r) {\n    r.set_width(5);\n    r.set_height(10);\n    assert(r.area() == 50);  // Fails for Square!\n}",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html#i---interface-segregation-principle",
    "href": "docs/patterns/solid.html#i---interface-segregation-principle",
    "title": "SOLID Principles",
    "section": "I - Interface Segregation Principle",
    "text": "I - Interface Segregation Principle\nClients shouldn’t depend on interfaces they don’t use.\n// BAD: Printer forced to implement fax\nstruct IMachine {\n    virtual void print() = 0;\n    virtual void scan() = 0;\n    virtual void fax() = 0;  // ❌ Not all machines fax\n};\n\n// GOOD: Separate interfaces\nstruct IPrinter { virtual void print() = 0; };\nstruct IScanner { virtual void scan() = 0; };\nstruct IFax { virtual void fax() = 0; };\n\nstruct MultiFunctionDevice : IPrinter, IScanner { /* ... */ };\nstruct SimplePrinter : IPrinter { /* ... */ };",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html#d---dependency-inversion-principle",
    "href": "docs/patterns/solid.html#d---dependency-inversion-principle",
    "title": "SOLID Principles",
    "section": "D - Dependency Inversion Principle",
    "text": "D - Dependency Inversion Principle\nDepend on abstractions, not concretions.\n// BAD: High-level depends on low-level implementation\nstruct Research {\n    Research(Relationships& r) {\n        for (auto& [p, rel, c] : r.relations) { /* ... */ }  // ❌\n    }\n};\n\n// GOOD: Depend on abstraction\nstruct RelationshipBrowser {\n    virtual std::vector&lt;Person&gt; find_children(const std::string& name) = 0;\n};\n\nstruct Research {\n    Research(RelationshipBrowser& browser) {\n        for (auto& child : browser.find_children(\"John\")) { /* ... */ }\n    }\n};",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html#key-points",
    "href": "docs/patterns/solid.html#key-points",
    "title": "SOLID Principles",
    "section": "Key Points",
    "text": "Key Points\n\n\n\nPrinciple\nSummary\n\n\n\n\nSRP\nOne class, one responsibility\n\n\nOCP\nExtend behavior without modifying existing code\n\n\nLSP\nSubclasses must honor base class contracts\n\n\nISP\nMany specific interfaces &gt; one general interface\n\n\nDIP\nHigh-level code shouldn’t depend on low-level details",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/solid.html#see-also",
    "href": "docs/patterns/solid.html#see-also",
    "title": "SOLID Principles",
    "section": "See Also",
    "text": "See Also\n\nfactory - DIP in action\nadapter - OCP via wrapping",
    "crumbs": [
      "Patterns",
      "SOLID Principles"
    ]
  },
  {
    "objectID": "docs/patterns/structural/adapter.html",
    "href": "docs/patterns/structural/adapter.html",
    "title": "Adapter Pattern",
    "section": "",
    "text": "Convert one interface to another.",
    "crumbs": [
      "Patterns",
      "Adapter Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/structural/adapter.html#class-diagram",
    "href": "docs/patterns/structural/adapter.html#class-diagram",
    "title": "Adapter Pattern",
    "section": "Class Diagram",
    "text": "Class Diagram\nClient → Target (interface)\n              ↑\n           Adapter → Adaptee",
    "crumbs": [
      "Patterns",
      "Adapter Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/structural/adapter.html#implementation",
    "href": "docs/patterns/structural/adapter.html#implementation",
    "title": "Adapter Pattern",
    "section": "Implementation",
    "text": "Implementation\n// Target interface (what client expects)\nclass Target {\npublic:\n    virtual ~Target() = default;\n    virtual std::string request() const {\n        return \"Target: default behavior\";\n    }\n};\n\n// Adaptee (incompatible interface)\nclass Adaptee {\npublic:\n    std::string specificRequest() const {\n        return \".eetpadA eht fo roivaheb laicepS\";  // reversed\n    }\n};\n\n// Adapter makes Adaptee work with Target interface\nclass Adapter : public Target {\n    std::shared_ptr&lt;Adaptee&gt; adaptee_;\n\npublic:\n    Adapter(std::shared_ptr&lt;Adaptee&gt; adaptee) : adaptee_(adaptee) {}\n\n    std::string request() const override {\n        std::string result = adaptee_-&gt;specificRequest();\n        std::reverse(result.begin(), result.end());\n        return \"Adapter: (TRANSLATED) \" + result;\n    }\n};",
    "crumbs": [
      "Patterns",
      "Adapter Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/structural/adapter.html#usage",
    "href": "docs/patterns/structural/adapter.html#usage",
    "title": "Adapter Pattern",
    "section": "Usage",
    "text": "Usage\nvoid clientCode(const std::shared_ptr&lt;Target&gt;& target) {\n    std::cout &lt;&lt; target-&gt;request() &lt;&lt; \"\\n\";\n}\n\n// Client works with Target\nauto target = std::make_shared&lt;Target&gt;();\nclientCode(target);\n\n// Adaptee has incompatible interface\nauto adaptee = std::make_shared&lt;Adaptee&gt;();\n// clientCode(adaptee);  // Won't work!\n\n// Adapter makes it work\nauto adapter = std::make_shared&lt;Adapter&gt;(adaptee);\nclientCode(adapter);  // Works!",
    "crumbs": [
      "Patterns",
      "Adapter Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/structural/adapter.html#object-vs-class-adapter",
    "href": "docs/patterns/structural/adapter.html#object-vs-class-adapter",
    "title": "Adapter Pattern",
    "section": "Object vs Class Adapter",
    "text": "Object vs Class Adapter\nObject Adapter (composition):\nclass Adapter : public Target {\n    Adaptee* adaptee_;  // composition\n};\nClass Adapter (multiple inheritance):\nclass Adapter : public Target, private Adaptee {\n    // inherits from both\n};\nObject adapter is more flexible and preferred.",
    "crumbs": [
      "Patterns",
      "Adapter Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/structural/adapter.html#key-points",
    "href": "docs/patterns/structural/adapter.html#key-points",
    "title": "Adapter Pattern",
    "section": "Key Points",
    "text": "Key Points\n\nConverts interface without modifying original classes\nEnables incompatible classes to work together\nObject adapter uses composition (preferred)\nClass adapter uses multiple inheritance\nOften used with legacy code or third-party libraries",
    "crumbs": [
      "Patterns",
      "Adapter Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/structural/adapter.html#see-also",
    "href": "docs/patterns/structural/adapter.html#see-also",
    "title": "Adapter Pattern",
    "section": "See Also",
    "text": "See Also\n\npimpl - implementation hiding\nsolid - Open/Closed Principle",
    "crumbs": [
      "Patterns",
      "Adapter Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/multiton.html",
    "href": "docs/patterns/creational/multiton.html",
    "title": "Multiton Pattern",
    "section": "",
    "text": "Named instances with controlled creation (variation of Singleton).",
    "crumbs": [
      "Patterns",
      "Multiton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/multiton.html#implementation",
    "href": "docs/patterns/creational/multiton.html#implementation",
    "title": "Multiton Pattern",
    "section": "Implementation",
    "text": "Implementation\ntemplate &lt;typename T&gt;\nclass Multiton {\n  public:\n    static std::shared_ptr&lt;Multiton&lt;T&gt;&gt; getInstance(const std::string &key) {\n        if (instances.find(key) == instances.end()) {\n            instances[key] = std::shared_ptr&lt;Multiton&lt;T&gt;&gt;(new Multiton&lt;T&gt;(key));\n        }\n        return instances[key];\n    }\n\n    void display() const { std::cout &lt;&lt; \"Instance with key: \" &lt;&lt; key &lt;&lt; std::endl; }\n\n  private:\n    Multiton(const std::string &key) : key(key) {}\n    std::string key;\n    static std::map&lt;std::string, std::shared_ptr&lt;Multiton&lt;T&gt;&gt;&gt; instances;\n};\n\ntemplate &lt;typename T&gt;\nstd::map&lt;std::string, std::shared_ptr&lt;Multiton&lt;T&gt;&gt;&gt; Multiton&lt;T&gt;::instances;",
    "crumbs": [
      "Patterns",
      "Multiton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/multiton.html#usage",
    "href": "docs/patterns/creational/multiton.html#usage",
    "title": "Multiton Pattern",
    "section": "Usage",
    "text": "Usage\nauto instance1 = Multiton&lt;int&gt;::getInstance(\"key1\");\nauto instance2 = Multiton&lt;double&gt;::getInstance(\"key2\");\nauto instance3 = Multiton&lt;int&gt;::getInstance(\"key1\");\nauto instance4 = Multiton&lt;double&gt;::getInstance(\"key2\");\n\n// instance1 == instance3 (same key, same type)\n// instance2 == instance4 (same key, same type)",
    "crumbs": [
      "Patterns",
      "Multiton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/multiton.html#key-points",
    "href": "docs/patterns/creational/multiton.html#key-points",
    "title": "Multiton Pattern",
    "section": "Key Points",
    "text": "Key Points\n\nLike Singleton but with named instances\nEach unique key returns the same instance\nDifferent types maintain separate instance maps\nPrivate constructor prevents direct instantiation",
    "crumbs": [
      "Patterns",
      "Multiton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/multiton.html#see-also",
    "href": "docs/patterns/creational/multiton.html#see-also",
    "title": "Multiton Pattern",
    "section": "See Also",
    "text": "See Also\n\nsingleton - single instance pattern\nfactory - object creation",
    "crumbs": [
      "Patterns",
      "Multiton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/singleton.html",
    "href": "docs/patterns/creational/singleton.html",
    "title": "Singleton Pattern",
    "section": "",
    "text": "Ensure a class has only one instance.",
    "crumbs": [
      "Patterns",
      "Singleton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/singleton.html#thread-safe-singleton-modern-c",
    "href": "docs/patterns/creational/singleton.html#thread-safe-singleton-modern-c",
    "title": "Singleton Pattern",
    "section": "Thread-Safe Singleton (Modern C++)",
    "text": "Thread-Safe Singleton (Modern C++)\nclass Singleton {\n    static std::unique_ptr&lt;Singleton&gt; instance;\n    static std::once_flag init_flag;\n\n    Singleton() = default;  // private constructor\n\npublic:\n    // Delete copy operations\n    Singleton(const Singleton&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n\n    static Singleton* getInstance() {\n        std::call_once(init_flag, []() {\n            instance.reset(new Singleton());\n        });\n        return instance.get();\n    }\n\n    void doSomething() { /* ... */ }\n};\n\n// Initialize statics\nstd::unique_ptr&lt;Singleton&gt; Singleton::instance = nullptr;\nstd::once_flag Singleton::init_flag;",
    "crumbs": [
      "Patterns",
      "Singleton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/singleton.html#meyers-singleton-simpler",
    "href": "docs/patterns/creational/singleton.html#meyers-singleton-simpler",
    "title": "Singleton Pattern",
    "section": "Meyers Singleton (Simpler)",
    "text": "Meyers Singleton (Simpler)\nclass Singleton {\n    Singleton() = default;\n\npublic:\n    Singleton(const Singleton&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n\n    static Singleton& getInstance() {\n        static Singleton instance;  // C++11 guarantees thread-safe\n        return instance;\n    }\n};",
    "crumbs": [
      "Patterns",
      "Singleton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/singleton.html#usage",
    "href": "docs/patterns/creational/singleton.html#usage",
    "title": "Singleton Pattern",
    "section": "Usage",
    "text": "Usage\nSingleton::getInstance().doSomething();\n\n// Or store reference\nSingleton& s = Singleton::getInstance();\ns.doSomething();",
    "crumbs": [
      "Patterns",
      "Singleton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/singleton.html#when-to-use",
    "href": "docs/patterns/creational/singleton.html#when-to-use",
    "title": "Singleton Pattern",
    "section": "When to Use",
    "text": "When to Use\nGood for: - Logger - Configuration manager - Hardware interface manager\nAvoid when: - Testing is important (hard to mock) - Multiple instances might be needed later",
    "crumbs": [
      "Patterns",
      "Singleton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/singleton.html#key-points",
    "href": "docs/patterns/creational/singleton.html#key-points",
    "title": "Singleton Pattern",
    "section": "Key Points",
    "text": "Key Points\n\nPrivate constructor prevents external instantiation\nDelete copy constructor and assignment\nC++11 static locals are thread-safe (Meyers singleton)\nstd::call_once for explicit thread-safety\nConsider dependency injection instead",
    "crumbs": [
      "Patterns",
      "Singleton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/singleton.html#see-also",
    "href": "docs/patterns/creational/singleton.html#see-also",
    "title": "Singleton Pattern",
    "section": "See Also",
    "text": "See Also\n\nfactory - controlled creation\nmutex - thread synchronization",
    "crumbs": [
      "Patterns",
      "Singleton Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/prototype.html",
    "href": "docs/patterns/creational/prototype.html",
    "title": "Prototype Pattern",
    "section": "",
    "text": "Create new objects by cloning existing ones.",
    "crumbs": [
      "Patterns",
      "Prototype Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/prototype.html#basic-prototype",
    "href": "docs/patterns/creational/prototype.html#basic-prototype",
    "title": "Prototype Pattern",
    "section": "Basic Prototype",
    "text": "Basic Prototype\nclass Prototype {\npublic:\n    virtual ~Prototype() = default;\n    virtual std::unique_ptr&lt;Prototype&gt; clone() const = 0;\n    virtual void print() const = 0;\n};\n\nclass ConcretePrototype : public Prototype {\n    std::string name_;\npublic:\n    ConcretePrototype(const std::string& name) : name_(name) {}\n\n    std::unique_ptr&lt;Prototype&gt; clone() const override {\n        return std::make_unique&lt;ConcretePrototype&gt;(*this);\n    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"ConcretePrototype: \" &lt;&lt; name_ &lt;&lt; \"\\n\";\n    }\n};",
    "crumbs": [
      "Patterns",
      "Prototype Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/prototype.html#prototype-factory",
    "href": "docs/patterns/creational/prototype.html#prototype-factory",
    "title": "Prototype Pattern",
    "section": "Prototype Factory",
    "text": "Prototype Factory\nclass PrototypeFactory {\n    std::unordered_map&lt;std::string, std::unique_ptr&lt;Prototype&gt;&gt; prototypes_;\n\npublic:\n    PrototypeFactory() {\n        prototypes_[\"type1\"] = std::make_unique&lt;ConcretePrototype1&gt;(\"Default1\");\n        prototypes_[\"type2\"] = std::make_unique&lt;ConcretePrototype2&gt;(\"Default2\");\n    }\n\n    std::unique_ptr&lt;Prototype&gt; create(const std::string& type) {\n        return prototypes_[type]-&gt;clone();\n    }\n};",
    "crumbs": [
      "Patterns",
      "Prototype Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/prototype.html#usage",
    "href": "docs/patterns/creational/prototype.html#usage",
    "title": "Prototype Pattern",
    "section": "Usage",
    "text": "Usage\nPrototypeFactory factory;\n\nauto obj1 = factory.create(\"type1\");\nauto obj2 = factory.create(\"type1\");  // independent clone\n\nobj1-&gt;print();\nobj2-&gt;print();",
    "crumbs": [
      "Patterns",
      "Prototype Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/prototype.html#when-to-use",
    "href": "docs/patterns/creational/prototype.html#when-to-use",
    "title": "Prototype Pattern",
    "section": "When to Use",
    "text": "When to Use\n\nCreating objects is expensive (database, network)\nObjects have many shared properties\nNeed to avoid subclasses of factories\nRuntime configuration of which classes to instantiate",
    "crumbs": [
      "Patterns",
      "Prototype Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/prototype.html#key-points",
    "href": "docs/patterns/creational/prototype.html#key-points",
    "title": "Prototype Pattern",
    "section": "Key Points",
    "text": "Key Points\n\nClone method creates deep copy\nPrototype registry stores clonable templates\nAvoids cost of standard construction\nEach clone is independent\nImplement proper copy semantics",
    "crumbs": [
      "Patterns",
      "Prototype Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/prototype.html#see-also",
    "href": "docs/patterns/creational/prototype.html#see-also",
    "title": "Prototype Pattern",
    "section": "See Also",
    "text": "See Also\n\nfactory - alternative creation pattern\nbuilder - step-by-step construction",
    "crumbs": [
      "Patterns",
      "Prototype Pattern"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html",
    "href": "docs/classes/constructors.html",
    "title": "Constructors",
    "section": "",
    "text": "Object initialization and construction.",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#default-constructor",
    "href": "docs/classes/constructors.html#default-constructor",
    "title": "Constructors",
    "section": "Default Constructor",
    "text": "Default Constructor\nCan be called without arguments:\nstruct A {\n    A() = default; // explicit default (same as A() {})\n};\n\nstruct B {\n    int a = 0; // has implicit default constructor\n};\n\nstruct C {\n    C() = delete; // deleted default constructor\n};\n\nstruct D {\n    D(int a) {}   // user-defined: implicit default is deleted\n    int& x;       // reference member: default deleted\n    const int y;  // const member: default deleted\n    C c;          // member with deleted default: default deleted\n};\nUsage:\nA a;   // calls default constructor\nA b(); // WARNING: declares a function!\nA c{}; // calls default constructor (preferred)",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#delegating-constructor",
    "href": "docs/classes/constructors.html#delegating-constructor",
    "title": "Constructors",
    "section": "Delegating Constructor",
    "text": "Delegating Constructor\nstruct A {\n    int a, b;\n    float c;\n\n    A() : A(1, 2, 3.14f) {} // delegates to other constructor\n    A(int a, int b, float c) : a{a}, b{b}, c{c} {}\n};",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#copy-constructor",
    "href": "docs/classes/constructors.html#copy-constructor",
    "title": "Constructors",
    "section": "Copy Constructor",
    "text": "Copy Constructor\nCreates a deep copy:\nstruct A {\n    A() = default;\n    A(const A&) {} // copy constructor\n};\n\nvoid f(A a) {}\nA g(A& a) { return a; }\n\nA a;\nA b{a};    // copy constructor\nA c = a;   // copy constructor\nf(a);      // copy constructor (pass by value)\ng(a);      // copy constructor (return)\nImplicitly deleted when: - Has non-static reference/const member - Has member with deleted copy constructor - Has move constructor",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#move-constructor",
    "href": "docs/classes/constructors.html#move-constructor",
    "title": "Constructors",
    "section": "Move Constructor",
    "text": "Move Constructor\nclass A {\npublic:\n    A();                       // default\n    A(const A& a);             // copy constructor\n    A(A&& rhs);                // move constructor\n    A& operator=(const A& a);  // copy assignment\n    A& operator=(A&& rhs);     // move assignment\n    ~A();                      // destructor\n};",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#member-initialization",
    "href": "docs/classes/constructors.html#member-initialization",
    "title": "Constructors",
    "section": "Member Initialization",
    "text": "Member Initialization\nstruct A {\n    int a;\n    int b;\n    float c = 3.14f;     // in-class initializer\n    int* ptr = nullptr;  // in-class initializer\n    int& ref = a;        // reference: must initialize\n    const int x;         // const: must initialize\n\n    // Member initialization list\n    A() : a{1}, b{2}, x{0} {}\n};\nOrder matters:\nstruct B {\n    int* array;\n    int size;\n\n    // BUG: array uses size, but size is declared after array!\n    B() : size{10}, array{new int[size]} {} // WRONG\n};\nMembers initialize in declaration order, not list order.",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#explicit-keyword",
    "href": "docs/classes/constructors.html#explicit-keyword",
    "title": "Constructors",
    "section": "explicit Keyword",
    "text": "explicit Keyword\nPrevents implicit conversions:\nstruct A {\n    A(int) {}\n};\nstruct B {\n    explicit B(int) {}\n};\n\nvoid f(const A&);\nvoid g(const B&);\n\nf(1);      // OK: implicit A(1)\n// g(1);   // ERROR: B(int) is explicit\ng(B{1});   // OK: explicit construction",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#key-points",
    "href": "docs/classes/constructors.html#key-points",
    "title": "Constructors",
    "section": "Key Points",
    "text": "Key Points\n\n= default for compiler-generated implementation\n= delete to forbid a constructor\nInitialization list order follows declaration order\nUse explicit to prevent implicit conversions\nRule of 5: if you define one special member, consider all five",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/constructors.html#see-also",
    "href": "docs/classes/constructors.html#see-also",
    "title": "Constructors",
    "section": "See Also",
    "text": "See Also\n\ndestructors - cleanup\ncopy-move - copy and move semantics",
    "crumbs": [
      "Classes",
      "Constructors"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html",
    "href": "docs/classes/object-layout.html",
    "title": "Object Layout",
    "section": "",
    "text": "How objects are stored in memory.",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html#aggregate",
    "href": "docs/classes/object-layout.html#aggregate",
    "title": "Object Layout",
    "section": "Aggregate",
    "text": "Aggregate\nSupports aggregate initialization {}:\nstruct Aggregate {\n    int a;\n    int b[3];\n    int c{2};  // default member initializer OK\n\n    Aggregate() = default;  // OK: not user-provided\n    void f();               // OK: member functions allowed\nprivate:\n    void g();               // OK: private functions allowed\n};\n\nAggregate x{1, {2,3,4}, 5};\nstatic_assert(std::is_aggregate_v&lt;Aggregate&gt;);\nNOT aggregate if: - User-provided constructor - Private/protected non-static data members - Virtual base classes or functions - Private/protected base classes",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html#trivially-copyable",
    "href": "docs/classes/object-layout.html#trivially-copyable",
    "title": "Object Layout",
    "section": "Trivially Copyable",
    "text": "Trivially Copyable\nCan be copied with memcpy:\nstruct Trivial {\n    Trivial() = default;\n    Trivial(int) {}  // non-default ctor OK\n    void f();\nprivate:\n    int x;  // private data OK\n};\n\nstatic_assert(std::is_trivially_copyable_v&lt;Trivial&gt;);\n\n// Safe to memcpy\nTrivial a, b;\nstd::memcpy(&b, &a, sizeof(Trivial));\nNOT trivially copyable if: - User-provided copy/move constructor or assignment - Virtual functions",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html#standard-layout",
    "href": "docs/classes/object-layout.html#standard-layout",
    "title": "Object Layout",
    "section": "Standard Layout",
    "text": "Standard Layout\nCompatible with C structs:\nstruct Standard {\n    Standard() {}  // user-provided OK\n    int a;\n    int b;\n    void f();\nprivate:\n    static int x;  // private static OK\n};\n\nstatic_assert(std::is_standard_layout_v&lt;Standard&gt;);\nNOT standard layout if: - Virtual functions - Multiple access specifiers for non-static data - Base class with non-static data members - First member same type as base class",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html#pod-plain-old-data",
    "href": "docs/classes/object-layout.html#pod-plain-old-data",
    "title": "Object Layout",
    "section": "POD (Plain Old Data)",
    "text": "POD (Plain Old Data)\nDeprecated in C++20. Was: trivially copyable + standard layout.\n// Use these instead:\nstatic_assert(std::is_trivially_copyable_v&lt;T&gt;);\nstatic_assert(std::is_standard_layout_v&lt;T&gt;);",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html#summary-table",
    "href": "docs/classes/object-layout.html#summary-table",
    "title": "Object Layout",
    "section": "Summary Table",
    "text": "Summary Table\n\n\n\nProperty\nAllows\n\n\n\n\nAggregate\n{} initialization\n\n\nTrivially Copyable\nmemcpy safe\n\n\nStandard Layout\nC-compatible layout",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html#key-points",
    "href": "docs/classes/object-layout.html#key-points",
    "title": "Object Layout",
    "section": "Key Points",
    "text": "Key Points\n\nAggregate: brace initialization\nTrivially copyable: safe bitwise copy\nStandard layout: predictable memory layout\nCheck with type traits at compile time\nPOD is deprecated; use narrower concepts",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/object-layout.html#see-also",
    "href": "docs/classes/object-layout.html#see-also",
    "title": "Object Layout",
    "section": "See Also",
    "text": "See Also\n\nconstructors - how constructors affect layout\nvirtual - vtables affect layout",
    "crumbs": [
      "Classes",
      "Object Layout"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html",
    "href": "docs/classes/inheritance.html",
    "title": "Inheritance",
    "section": "",
    "text": "Class hierarchies and derived types.",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html#basic-inheritance",
    "href": "docs/classes/inheritance.html#basic-inheritance",
    "title": "Inheritance",
    "section": "Basic Inheritance",
    "text": "Basic Inheritance\nstruct Base { int x; };\nstruct Derived : Base { int y; };\n\nDerived d;\nd.x = 1;  // inherited from Base\nd.y = 2;  // own member",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html#implicit-conversions",
    "href": "docs/classes/inheritance.html#implicit-conversions",
    "title": "Inheritance",
    "section": "Implicit Conversions",
    "text": "Implicit Conversions\nDerived can be used where Base is expected:\nvoid f(Base& b);\nvoid g(Base* b);\nvoid h(Base b);   // slicing!\n\nDerived d;\nf(d);   // OK: reference to Base\ng(&d);  // OK: pointer to Base\nh(d);   // OK but slices: only Base part copied\n\nBase& ref = d;  // OK\nBase* ptr = &d; // OK",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html#object-slicing",
    "href": "docs/classes/inheritance.html#object-slicing",
    "title": "Inheritance",
    "section": "Object Slicing",
    "text": "Object Slicing\nstruct Base { virtual void f() { std::cout &lt;&lt; \"Base\"; } };\nstruct Derived : Base { void f() override { std::cout &lt;&lt; \"Derived\"; } };\n\nDerived d;\nBase b = d;  // SLICED: only Base part copied\nb.f();       // \"Base\" (not \"Derived\")\nAlways use pointers or references for polymorphism.",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html#upcasting-and-downcasting",
    "href": "docs/classes/inheritance.html#upcasting-and-downcasting",
    "title": "Inheritance",
    "section": "Upcasting and Downcasting",
    "text": "Upcasting and Downcasting\nstruct A { virtual void f() {} };\nstruct B : A {};\nstruct C : A {};\n\nB b;\n\n// Upcasting (safe, implicit)\nA& a1 = b;\nA* a2 = &b;\n\n// Downcasting (unsafe, explicit)\nB& b1 = static_cast&lt;B&&gt;(a1);     // unchecked\nB& b2 = dynamic_cast&lt;B&&gt;(a1);    // checked, throws if wrong\nB* b3 = dynamic_cast&lt;B*&gt;(a2);    // checked, nullptr if wrong\n\n// Sidecasting (between siblings)\n// C* c = static_cast&lt;C*&gt;(&b);   // ERROR\nC* c = dynamic_cast&lt;C*&gt;(&b);     // nullptr (b is not C)",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html#rtti-run-time-type-information",
    "href": "docs/classes/inheritance.html#rtti-run-time-type-information",
    "title": "Inheritance",
    "section": "RTTI (Run-Time Type Information)",
    "text": "RTTI (Run-Time Type Information)\nstruct A { virtual void f() {} };\nstruct B : A {};\n\nA a;\nB b;\nA& ref = b;\n\ntypeid(a).name();    // \"A\" (mangled)\ntypeid(b).name();    // \"B\"\ntypeid(ref).name();  // \"B\" (dynamic type!)\n\nif (typeid(ref) == typeid(B)) {\n    // ref's dynamic type is B\n}",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html#key-points",
    "href": "docs/classes/inheritance.html#key-points",
    "title": "Inheritance",
    "section": "Key Points",
    "text": "Key Points\n\nDerived-to-base conversion is implicit and safe\nBase-to-derived (downcasting) requires explicit cast\ndynamic_cast performs runtime checking\nstatic_cast is unchecked (faster but dangerous)\nAlways use references/pointers for polymorphism\nObject slicing loses derived data",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/inheritance.html#see-also",
    "href": "docs/classes/inheritance.html#see-also",
    "title": "Inheritance",
    "section": "See Also",
    "text": "See Also\n\nvirtual - virtual functions\nbasics - access specifiers",
    "crumbs": [
      "Classes",
      "Inheritance"
    ]
  },
  {
    "objectID": "docs/classes/operators.html",
    "href": "docs/classes/operators.html",
    "title": "Operator Overloading",
    "section": "",
    "text": "Custom operators for user-defined types.",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/operators.html#conversion-operators",
    "href": "docs/classes/operators.html#conversion-operators",
    "title": "Operator Overloading",
    "section": "Conversion Operators",
    "text": "Conversion Operators\nstruct A {\n    explicit operator int() const { return 1; }  // explicit conversion\n    operator double() const { return 2.0; }       // implicit conversion\n};\n\nA a;\nint x = static_cast&lt;int&gt;(a); // OK: explicit\ndouble y = a;                 // OK: implicit\n// int z = a;                 // ERROR: int conversion is explicit",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/operators.html#incrementdecrement",
    "href": "docs/classes/operators.html#incrementdecrement",
    "title": "Operator Overloading",
    "section": "Increment/Decrement",
    "text": "Increment/Decrement\nstruct A {\n    int x = 0;\n\n    A& operator++() {      // prefix: ++a\n        x++;\n        return *this;       // return new value by reference\n    }\n\n    A operator++(int) {    // postfix: a++\n        A tmp = *this;\n        ++*this;            // use prefix\n        return tmp;         // return old value by value\n    }\n};",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/operators.html#copy-swap-idiom",
    "href": "docs/classes/operators.html#copy-swap-idiom",
    "title": "Operator Overloading",
    "section": "Copy-Swap Idiom",
    "text": "Copy-Swap Idiom\nException-safe assignment:\nstruct A {\n    int x;\n\n    friend void swap(A& a, A& b) {\n        using std::swap;\n        swap(a.x, b.x);\n    }\n\n    A& operator=(A other) {  // pass by value (copy)\n        swap(*this, other);   // swap with copy\n        return *this;         // old data destroyed with 'other'\n    }\n};",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/operators.html#stream-operators",
    "href": "docs/classes/operators.html#stream-operators",
    "title": "Operator Overloading",
    "section": "Stream Operators",
    "text": "Stream Operators\nstruct A {\n    int x;\n\n    friend std::ostream& operator&lt;&lt;(std::ostream& os, const A& a) {\n        os &lt;&lt; a.x;\n        return os;\n    }\n};",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/operators.html#binary-operators",
    "href": "docs/classes/operators.html#binary-operators",
    "title": "Operator Overloading",
    "section": "Binary Operators",
    "text": "Binary Operators\nImplement as friend for symmetry:\nstruct B {\n    int x;\n\n    // B == B works\n    // But without friend: B == A works, A == B doesn't\n    friend bool operator==(const B& lhs, const B& rhs) {\n        return lhs.x == rhs.x;\n    }\n};",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/operators.html#key-points",
    "href": "docs/classes/operators.html#key-points",
    "title": "Operator Overloading",
    "section": "Key Points",
    "text": "Key Points\n\nUse explicit for conversion operators that might cause surprises\nPrefix returns reference, postfix returns copy\nCopy-swap idiom provides exception safety\nBinary operators should be friends or free functions\nC++20 adds &lt;=&gt; (spaceship) for comparison operators",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/operators.html#see-also",
    "href": "docs/classes/operators.html#see-also",
    "title": "Operator Overloading",
    "section": "See Also",
    "text": "See Also\n\ncopy-move - copy and move assignment\nvirtual - polymorphic operators",
    "crumbs": [
      "Classes",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html",
    "href": "docs/classes/copy-move.html",
    "title": "Copy and Move",
    "section": "",
    "text": "Value semantics and efficient transfers.",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#special-member-functions",
    "href": "docs/classes/copy-move.html#special-member-functions",
    "title": "Copy and Move",
    "section": "Special Member Functions",
    "text": "Special Member Functions\nclass A {\npublic:\n    A();                       // default constructor\n    A(const A& a);             // copy constructor\n    A(A&& a);                  // move constructor\n    A& operator=(const A& a);  // copy assignment\n    A& operator=(A&& a);       // move assignment\n    ~A();                      // destructor\n};",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#copy-semantics",
    "href": "docs/classes/copy-move.html#copy-semantics",
    "title": "Copy and Move",
    "section": "Copy Semantics",
    "text": "Copy Semantics\nDeep copy - new independent object:\nstruct Widget {\n    int* data;\n\n    Widget(const Widget& other)\n        : data(new int(*other.data)) {} // deep copy\n\n    Widget& operator=(const Widget& other) {\n        if (this != &other) {\n            delete data;\n            data = new int(*other.data);\n        }\n        return *this;\n    }\n};",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#move-semantics-c11",
    "href": "docs/classes/copy-move.html#move-semantics-c11",
    "title": "Copy and Move",
    "section": "Move Semantics (C++11)",
    "text": "Move Semantics (C++11)\nTransfer ownership - source left in valid but unspecified state:\nstruct Widget {\n    int* data;\n\n    Widget(Widget&& other) noexcept\n        : data(other.data) {\n        other.data = nullptr;  // leave source empty\n    }\n\n    Widget& operator=(Widget&& other) noexcept {\n        if (this != &other) {\n            delete data;\n            data = other.data;\n            other.data = nullptr;\n        }\n        return *this;\n    }\n};",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#when-each-is-called",
    "href": "docs/classes/copy-move.html#when-each-is-called",
    "title": "Copy and Move",
    "section": "When Each Is Called",
    "text": "When Each Is Called\nWidget w1;\nWidget w2 = w1;           // copy constructor\nWidget w3 = std::move(w1); // move constructor\n\nw2 = w3;                  // copy assignment\nw2 = std::move(w3);       // move assignment\nw2 = Widget{};            // move assignment (temporary)",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#rule-of-zerothreefive",
    "href": "docs/classes/copy-move.html#rule-of-zerothreefive",
    "title": "Copy and Move",
    "section": "Rule of Zero/Three/Five",
    "text": "Rule of Zero/Three/Five\nRule of Zero: Don’t define any special members if you don’t need to.\nRule of Three (pre-C++11): If you define destructor, copy constructor, or copy assignment, define all three.\nRule of Five (C++11+): Add move constructor and move assignment to the three.\n// Rule of Zero - preferred\nstruct Modern {\n    std::vector&lt;int&gt; data;  // handles everything\n};\n\n// Rule of Five - when needed\nstruct Legacy {\n    int* raw;\n    Legacy();\n    ~Legacy();\n    Legacy(const Legacy&);\n    Legacy(Legacy&&) noexcept;\n    Legacy& operator=(const Legacy&);\n    Legacy& operator=(Legacy&&) noexcept;\n};",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#copy-elision-rvo",
    "href": "docs/classes/copy-move.html#copy-elision-rvo",
    "title": "Copy and Move",
    "section": "Copy Elision (RVO)",
    "text": "Copy Elision (RVO)\nCompiler can skip copy/move:\nWidget create() {\n    return Widget{};  // may construct directly at call site\n}\n\nWidget w = create();  // no copy/move (RVO)\nC++17 guarantees RVO in many cases.",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#key-points",
    "href": "docs/classes/copy-move.html#key-points",
    "title": "Copy and Move",
    "section": "Key Points",
    "text": "Key Points\n\nCopy creates independent duplicate\nMove transfers ownership (faster)\nUse std::move to enable move\nMark move operations noexcept\nFollow Rule of Zero when possible\nCompiler may elide copies (RVO)",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/classes/copy-move.html#see-also",
    "href": "docs/classes/copy-move.html#see-also",
    "title": "Copy and Move",
    "section": "See Also",
    "text": "See Also\n\nconstructors - constructor details\nraii - resource management",
    "crumbs": [
      "Classes",
      "Copy and Move"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html",
    "href": "docs/compilation/translation-units.html",
    "title": "Translation Units",
    "section": "",
    "text": "The unit of compilation in C++.",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html#what-is-a-translation-unit",
    "href": "docs/compilation/translation-units.html#what-is-a-translation-unit",
    "title": "Translation Units",
    "section": "What is a Translation Unit?",
    "text": "What is a Translation Unit?\nA source file after preprocessing: - Original .cpp file - Plus all #included headers (recursively) - With macros expanded\nsource.cpp + headers = translation unit → object file",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html#compilation-model",
    "href": "docs/compilation/translation-units.html#compilation-model",
    "title": "Translation Units",
    "section": "Compilation Model",
    "text": "Compilation Model\nsource1.cpp  →  [compile]  →  source1.o  ↘\nsource2.cpp  →  [compile]  →  source2.o  →  [link]  →  executable\nsource3.cpp  →  [compile]  →  source3.o  ↗\nEach .cpp compiles independently, then linker combines.",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html#one-definition-rule-odr",
    "href": "docs/compilation/translation-units.html#one-definition-rule-odr",
    "title": "Translation Units",
    "section": "One Definition Rule (ODR)",
    "text": "One Definition Rule (ODR)\n\nOne definition per TU: Variables, functions can only be defined once in a TU\nOne definition per program: Non-inline functions/variables defined once total\nMultiple definitions allowed: inline functions, templates, class definitions (must be identical)\n\n// ODR violation: defined twice in program\n// file1.cpp\nint x = 1;\n// file2.cpp\nint x = 2;  // ERROR at link time\n\n// OK: inline allows multiple definitions\n// header.hpp\ninline int y = 1;  // same definition in all TUs",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html#header-guards",
    "href": "docs/compilation/translation-units.html#header-guards",
    "title": "Translation Units",
    "section": "Header Guards",
    "text": "Header Guards\nPrevent multiple inclusion within one TU:\n// myheader.hpp\n#ifndef MYHEADER_HPP\n#define MYHEADER_HPP\n\n// declarations here\n\n#endif\n\n// Or modern (non-standard but universal)\n#pragma once",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html#include-vs-forward-declaration",
    "href": "docs/compilation/translation-units.html#include-vs-forward-declaration",
    "title": "Translation Units",
    "section": "Include vs Forward Declaration",
    "text": "Include vs Forward Declaration\n// Forward declaration (faster compile)\nclass Foo;\nvoid use_foo(Foo* f);\n\n// Full include (required for size/members)\n#include \"foo.hpp\"\nFoo create_foo();",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html#key-points",
    "href": "docs/compilation/translation-units.html#key-points",
    "title": "Translation Units",
    "section": "Key Points",
    "text": "Key Points\n\nEach .cpp is its own translation unit\nODR: one definition rule\nHeaders are copy-pasted by preprocessor\nUse header guards or #pragma once\nMinimize includes for faster compilation",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/translation-units.html#see-also",
    "href": "docs/compilation/translation-units.html#see-also",
    "title": "Translation Units",
    "section": "See Also",
    "text": "See Also\n\nlinkage - internal vs external linkage\ninline - multiple definition exception",
    "crumbs": [
      "Compilation",
      "Translation Units"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html",
    "href": "docs/compilation/linkage.html",
    "title": "Linkage",
    "section": "",
    "text": "How names are visible across translation units.",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#linkage-types",
    "href": "docs/compilation/linkage.html#linkage-types",
    "title": "Linkage",
    "section": "Linkage Types",
    "text": "Linkage Types\n\nNo linkage: Local variables, visible only in their scope\nInternal linkage: Visible only within the translation unit\nExternal linkage: Visible across translation units",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#internal-linkage",
    "href": "docs/compilation/linkage.html#internal-linkage",
    "title": "Linkage",
    "section": "Internal Linkage",
    "text": "Internal Linkage\nOnly visible within the current translation unit:\n// Anonymous namespace (preferred)\nnamespace {\n    void internal_func() {}\n    int internal_var = 0;\n}\n\n// static keyword (older style)\nstatic int static_var = 0;\nstatic int static_func() { return 1; }\n\n// const/constexpr at namespace scope (implicitly internal)\nconst int const_var = 42;\nconstexpr int constexpr_var = 43;",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#external-linkage",
    "href": "docs/compilation/linkage.html#external-linkage",
    "title": "Linkage",
    "section": "External Linkage",
    "text": "External Linkage\nVisible from other translation units:\n// lib.hpp (header)\nextern int extern_var;      // declaration\nint func();                 // declaration\n\n// lib.cpp (implementation)\nint extern_var = 77;        // definition\nint func() { return 66; }   // definition",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#declarations-vs-definitions",
    "href": "docs/compilation/linkage.html#declarations-vs-definitions",
    "title": "Linkage",
    "section": "Declarations vs Definitions",
    "text": "Declarations vs Definitions\n// Declarations (can appear in headers)\nextern int x;           // variable declaration\nvoid func();            // function declaration\nclass Foo;              // class declaration\n\n// Definitions (one per program)\nint x = 10;             // variable definition\nvoid func() { }         // function definition\nclass Foo { };          // class definition",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#what-has-external-linkage",
    "href": "docs/compilation/linkage.html#what-has-external-linkage",
    "title": "Linkage",
    "section": "What Has External Linkage",
    "text": "What Has External Linkage\n\nNon-static functions\nNon-static global variables\nClasses, structs, enums\nTemplate instantiations\nInline variables/functions (C++17)",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#what-has-internal-linkage",
    "href": "docs/compilation/linkage.html#what-has-internal-linkage",
    "title": "Linkage",
    "section": "What Has Internal Linkage",
    "text": "What Has Internal Linkage\n\nstatic functions and variables\nAnonymous namespace members\nconst/constexpr at namespace scope (without extern)",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#key-points",
    "href": "docs/compilation/linkage.html#key-points",
    "title": "Linkage",
    "section": "Key Points",
    "text": "Key Points\n\nPrefer anonymous namespaces over static\nextern declares without defining\nEach definition must appear exactly once (ODR)\nTemplates are special (see inline)",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/compilation/linkage.html#see-also",
    "href": "docs/compilation/linkage.html#see-also",
    "title": "Linkage",
    "section": "See Also",
    "text": "See Also\n\ninline - inline functions and variables\ntranslation-units - compilation model",
    "crumbs": [
      "Compilation",
      "Linkage"
    ]
  },
  {
    "objectID": "docs/concurrency/index.html",
    "href": "docs/concurrency/index.html",
    "title": "Concurrency",
    "section": "",
    "text": "Parallel and asynchronous programming.",
    "crumbs": [
      "Concurrency"
    ]
  },
  {
    "objectID": "docs/concurrency/index.html#topics",
    "href": "docs/concurrency/index.html#topics",
    "title": "Concurrency",
    "section": "Topics",
    "text": "Topics\n\nthreads - Thread creation and management\nmutex - Mutual exclusion and locks\ncondition-variable - Thread synchronization\natomic - Lock-free operations\nfuture-promise - Async result communication\nasync - High-level async execution",
    "crumbs": [
      "Concurrency"
    ]
  },
  {
    "objectID": "docs/concurrency/future-promise.html",
    "href": "docs/concurrency/future-promise.html",
    "title": "Future and Promise",
    "section": "",
    "text": "Asynchronous result communication.",
    "crumbs": [
      "Concurrency",
      "Future and Promise"
    ]
  },
  {
    "objectID": "docs/concurrency/future-promise.html#concept",
    "href": "docs/concurrency/future-promise.html#concept",
    "title": "Future and Promise",
    "section": "Concept",
    "text": "Concept\n\nPromise: producer sets the value\nFuture: consumer waits for and retrieves the value\n\n#include &lt;future&gt;\n\nstd::promise&lt;int&gt; p;\nstd::future&lt;int&gt; f = p.get_future();\n\n// Producer thread\nstd::thread producer([&p] {\n    p.set_value(42);\n});\n\n// Consumer\nint result = f.get();  // blocks until value is set\n\nproducer.join();",
    "crumbs": [
      "Concurrency",
      "Future and Promise"
    ]
  },
  {
    "objectID": "docs/concurrency/future-promise.html#packaged_task",
    "href": "docs/concurrency/future-promise.html#packaged_task",
    "title": "Future and Promise",
    "section": "packaged_task",
    "text": "packaged_task\nWraps a callable, provides a future:\nstd::packaged_task&lt;int(int, int)&gt; task([](int a, int b) {\n    return a + b;\n});\n\nstd::future&lt;int&gt; f = task.get_future();\n\n// Run task (must be called!)\ntask(2, 3);\n\n// Or move to a thread\nstd::thread t(std::move(task), 2, 3);\nt.join();\n\nint result = f.get();  // 5",
    "crumbs": [
      "Concurrency",
      "Future and Promise"
    ]
  },
  {
    "objectID": "docs/concurrency/future-promise.html#future-operations",
    "href": "docs/concurrency/future-promise.html#future-operations",
    "title": "Future and Promise",
    "section": "Future Operations",
    "text": "Future Operations\nstd::future&lt;int&gt; f = /* ... */;\n\nf.get();          // block and get result (only once!)\nf.wait();         // block until ready (no result)\nf.wait_for(100ms);   // wait with timeout\nf.wait_until(tp);    // wait until time point\n\nf.valid();        // true if has shared state",
    "crumbs": [
      "Concurrency",
      "Future and Promise"
    ]
  },
  {
    "objectID": "docs/concurrency/future-promise.html#key-points",
    "href": "docs/concurrency/future-promise.html#key-points",
    "title": "Future and Promise",
    "section": "Key Points",
    "text": "Key Points\n\nfuture::get() can only be called once\npromise::set_value() can only be called once\nUse shared_future if multiple consumers need the result\npackaged_task bridges callables to futures\nPromise-future is one-shot communication",
    "crumbs": [
      "Concurrency",
      "Future and Promise"
    ]
  },
  {
    "objectID": "docs/concurrency/future-promise.html#see-also",
    "href": "docs/concurrency/future-promise.html#see-also",
    "title": "Future and Promise",
    "section": "See Also",
    "text": "See Also\n\nasync - higher-level async\nthreads - raw threads",
    "crumbs": [
      "Concurrency",
      "Future and Promise"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html",
    "href": "docs/concurrency/atomic.html",
    "title": "Atomic Operations",
    "section": "",
    "text": "Lock-free thread-safe operations.",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html#basic-usage",
    "href": "docs/concurrency/atomic.html#basic-usage",
    "title": "Atomic Operations",
    "section": "Basic Usage",
    "text": "Basic Usage\n#include &lt;atomic&gt;\n\nstd::atomic&lt;int&gt; counter{0};\n\ncounter++;              // atomic increment\ncounter.load();         // atomic read\ncounter.store(10);      // atomic write\ncounter.exchange(20);   // atomic swap, returns old value",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html#atomic_flag",
    "href": "docs/concurrency/atomic.html#atomic_flag",
    "title": "Atomic Operations",
    "section": "atomic_flag",
    "text": "atomic_flag\nSimplest atomic type (guaranteed lock-free):\nstd::atomic_flag flag = ATOMIC_FLAG_INIT;\n\nflag.test_and_set();  // set and return previous value\nflag.clear();         // clear the flag",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html#spinlock-with-atomic_flag",
    "href": "docs/concurrency/atomic.html#spinlock-with-atomic_flag",
    "title": "Atomic Operations",
    "section": "Spinlock with atomic_flag",
    "text": "Spinlock with atomic_flag\nstd::atomic_flag lock = ATOMIC_FLAG_INIT;\n\nvoid acquire() {\n    while (lock.test_and_set(std::memory_order_acquire))\n        ; // spin\n}\n\nvoid release() {\n    lock.clear(std::memory_order_release);\n}",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html#compare-and-swap",
    "href": "docs/concurrency/atomic.html#compare-and-swap",
    "title": "Atomic Operations",
    "section": "Compare-and-Swap",
    "text": "Compare-and-Swap\nstd::atomic&lt;int&gt; value{5};\nint expected = 5;\n\n// If value == expected, set value to 10\nbool success = value.compare_exchange_strong(expected, 10);\n// If failed, expected now contains actual value\n\n// Weak version may fail spuriously (use in loops)\nwhile (!value.compare_exchange_weak(expected, 10)) {\n    // expected updated with current value\n}",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html#memory-order",
    "href": "docs/concurrency/atomic.html#memory-order",
    "title": "Atomic Operations",
    "section": "Memory Order",
    "text": "Memory Order\n// Default: sequential consistency (safest, slowest)\nx.store(1);  // same as x.store(1, std::memory_order_seq_cst)\n\n// Relaxed: only atomicity, no ordering\nx.store(1, std::memory_order_relaxed);\n\n// Acquire-Release: synchronizes between threads\nx.store(1, std::memory_order_release);  // writer\nx.load(std::memory_order_acquire);       // reader",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html#key-points",
    "href": "docs/concurrency/atomic.html#key-points",
    "title": "Atomic Operations",
    "section": "Key Points",
    "text": "Key Points\n\nAtomic operations are indivisible\natomic_flag is always lock-free\nstd::atomic&lt;T&gt; may use locks for large T\nUse memory_order_seq_cst unless you need performance\nAcquire-release for producer-consumer patterns",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/atomic.html#see-also",
    "href": "docs/concurrency/atomic.html#see-also",
    "title": "Atomic Operations",
    "section": "See Also",
    "text": "See Also\n\nmemory-order - memory ordering details\nmutex - when atomics aren’t enough",
    "crumbs": [
      "Concurrency",
      "Atomic Operations"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html",
    "href": "docs/concurrency/mutex.html",
    "title": "Mutex and Locks",
    "section": "",
    "text": "Thread synchronization primitives.",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html#basic-mutex",
    "href": "docs/concurrency/mutex.html#basic-mutex",
    "title": "Mutex and Locks",
    "section": "Basic Mutex",
    "text": "Basic Mutex\n#include &lt;mutex&gt;\n\nstd::mutex m;\n\nvoid safe_increment(int& counter) {\n    std::lock_guard&lt;std::mutex&gt; lock(m);\n    counter++;\n    // automatically unlocks when lock goes out of scope\n}",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html#lock-types",
    "href": "docs/concurrency/mutex.html#lock-types",
    "title": "Mutex and Locks",
    "section": "Lock Types",
    "text": "Lock Types\n// lock_guard: simple RAII lock\nstd::lock_guard&lt;std::mutex&gt; lg(m);\n\n// unique_lock: more flexible (can unlock/relock)\nstd::unique_lock&lt;std::mutex&gt; ul(m);\nul.unlock();\nul.lock();\n\n// scoped_lock (C++17): locks multiple mutexes, prevents deadlock\nstd::scoped_lock lock(mutex1, mutex2);\n\n// shared_lock: for reader-writer scenarios\nstd::shared_lock&lt;std::shared_mutex&gt; sl(shared_m);",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html#mutex-types",
    "href": "docs/concurrency/mutex.html#mutex-types",
    "title": "Mutex and Locks",
    "section": "Mutex Types",
    "text": "Mutex Types\nstd::mutex m;              // basic mutex\nstd::recursive_mutex rm;   // same thread can lock multiple times\nstd::timed_mutex tm;       // supports try_lock_for/until\nstd::shared_mutex sm;      // reader-writer (C++17)",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html#avoiding-deadlock",
    "href": "docs/concurrency/mutex.html#avoiding-deadlock",
    "title": "Mutex and Locks",
    "section": "Avoiding Deadlock",
    "text": "Avoiding Deadlock\nstd::mutex m1, m2;\n\n// BAD: potential deadlock\nvoid bad() {\n    std::lock_guard l1(m1);\n    std::lock_guard l2(m2);  // if another thread locks m2 then m1...\n}\n\n// GOOD: std::lock acquires both atomically\nvoid good() {\n    std::lock(m1, m2);\n    std::lock_guard l1(m1, std::adopt_lock);\n    std::lock_guard l2(m2, std::adopt_lock);\n}\n\n// BETTER (C++17): scoped_lock\nvoid better() {\n    std::scoped_lock lock(m1, m2);\n}",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html#call_once",
    "href": "docs/concurrency/mutex.html#call_once",
    "title": "Mutex and Locks",
    "section": "call_once",
    "text": "call_once\nEnsure code runs exactly once (thread-safe):\nstd::once_flag flag;\n\nvoid init() {\n    std::call_once(flag, []() {\n        // initialization code\n        // runs exactly once, even from multiple threads\n    });\n}",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html#key-points",
    "href": "docs/concurrency/mutex.html#key-points",
    "title": "Mutex and Locks",
    "section": "Key Points",
    "text": "Key Points\n\nAlways use RAII locks (lock_guard, scoped_lock)\nNever call lock() / unlock() manually\nUse scoped_lock for multiple mutexes\nshared_mutex for read-heavy workloads\ncall_once for thread-safe initialization",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/mutex.html#see-also",
    "href": "docs/concurrency/mutex.html#see-also",
    "title": "Mutex and Locks",
    "section": "See Also",
    "text": "See Also\n\ncondition-variable - waiting for conditions\natomic - lock-free operations",
    "crumbs": [
      "Concurrency",
      "Mutex and Locks"
    ]
  },
  {
    "objectID": "docs/concurrency/threads.html",
    "href": "docs/concurrency/threads.html",
    "title": "Threads",
    "section": "",
    "text": "Thread creation and management.",
    "crumbs": [
      "Concurrency",
      "Threads"
    ]
  },
  {
    "objectID": "docs/concurrency/threads.html#basic-usage",
    "href": "docs/concurrency/threads.html#basic-usage",
    "title": "Threads",
    "section": "Basic Usage",
    "text": "Basic Usage\n#include &lt;thread&gt;\n\nvoid task() {\n    // work\n}\n\nstd::thread t(task);\nt.join();  // wait for completion\n// or\nt.detach(); // run independently",
    "crumbs": [
      "Concurrency",
      "Threads"
    ]
  },
  {
    "objectID": "docs/concurrency/threads.html#thread-information",
    "href": "docs/concurrency/threads.html#thread-information",
    "title": "Threads",
    "section": "Thread Information",
    "text": "Thread Information\n// Hardware concurrency (hint for thread count)\nunsigned int n = std::thread::hardware_concurrency();\n\n// Current thread ID\nstd::this_thread::get_id();\n\n// Sleep\nusing namespace std::chrono_literals;\nstd::this_thread::sleep_for(100ms);\nstd::this_thread::sleep_until(time_point);\n\n// Yield\nstd::this_thread::yield();",
    "crumbs": [
      "Concurrency",
      "Threads"
    ]
  },
  {
    "objectID": "docs/concurrency/threads.html#passing-arguments",
    "href": "docs/concurrency/threads.html#passing-arguments",
    "title": "Threads",
    "section": "Passing Arguments",
    "text": "Passing Arguments\nvoid func(int x, std::string& s);\n\nint n = 42;\nstd::string str = \"hello\";\n\n// Arguments are copied by default\nstd::thread t1(func, n, std::ref(str));  // std::ref for reference\n\n// Move-only types\nstd::thread t2(func, 1, std::move(str));",
    "crumbs": [
      "Concurrency",
      "Threads"
    ]
  },
  {
    "objectID": "docs/concurrency/threads.html#raii-wrapper-c20-jthread",
    "href": "docs/concurrency/threads.html#raii-wrapper-c20-jthread",
    "title": "Threads",
    "section": "RAII Wrapper (C++20: jthread)",
    "text": "RAII Wrapper (C++20: jthread)\n// C++20: automatically joins on destruction\nstd::jthread t(task);\n// No need to call join() - destructor handles it\n\n// Also supports stop_token for cancellation\nstd::jthread t2([](std::stop_token token) {\n    while (!token.stop_requested()) {\n        // work\n    }\n});\nt2.request_stop();",
    "crumbs": [
      "Concurrency",
      "Threads"
    ]
  },
  {
    "objectID": "docs/concurrency/threads.html#key-points",
    "href": "docs/concurrency/threads.html#key-points",
    "title": "Threads",
    "section": "Key Points",
    "text": "Key Points\n\nAlways join() or detach() before thread destructor\nPass references with std::ref()\nhardware_concurrency() is a hint, not guaranteed\nPrefer std::jthread (C++20) for automatic joining\nThreads are move-only (cannot copy)",
    "crumbs": [
      "Concurrency",
      "Threads"
    ]
  },
  {
    "objectID": "docs/concurrency/threads.html#see-also",
    "href": "docs/concurrency/threads.html#see-also",
    "title": "Threads",
    "section": "See Also",
    "text": "See Also\n\nmutex - synchronization\nasync - higher-level async",
    "crumbs": [
      "Concurrency",
      "Threads"
    ]
  },
  {
    "objectID": "docs/concurrency/condition-variable.html",
    "href": "docs/concurrency/condition-variable.html",
    "title": "Condition Variables",
    "section": "",
    "text": "Wait for conditions in multi-threaded code.",
    "crumbs": [
      "Concurrency",
      "Condition Variables"
    ]
  },
  {
    "objectID": "docs/concurrency/condition-variable.html#basic-pattern",
    "href": "docs/concurrency/condition-variable.html#basic-pattern",
    "title": "Condition Variables",
    "section": "Basic Pattern",
    "text": "Basic Pattern\n#include &lt;condition_variable&gt;\n#include &lt;mutex&gt;\n\nstd::mutex m;\nstd::condition_variable cv;\nbool ready = false;\n\n// Producer\nvoid producer() {\n    {\n        std::lock_guard lock(m);\n        ready = true;\n    }\n    cv.notify_one();  // or notify_all()\n}\n\n// Consumer\nvoid consumer() {\n    std::unique_lock lock(m);\n    cv.wait(lock, []{ return ready; });  // waits until ready\n    // proceed with work\n}",
    "crumbs": [
      "Concurrency",
      "Condition Variables"
    ]
  },
  {
    "objectID": "docs/concurrency/condition-variable.html#wait-variants",
    "href": "docs/concurrency/condition-variable.html#wait-variants",
    "title": "Condition Variables",
    "section": "Wait Variants",
    "text": "Wait Variants\nstd::unique_lock lock(m);\n\n// Wait indefinitely\ncv.wait(lock);\n\n// Wait with predicate (handles spurious wakeups)\ncv.wait(lock, []{ return condition; });\n\n// Wait with timeout\ncv.wait_for(lock, 100ms);\ncv.wait_for(lock, 100ms, []{ return condition; });\n\ncv.wait_until(lock, time_point);\ncv.wait_until(lock, time_point, []{ return condition; });",
    "crumbs": [
      "Concurrency",
      "Condition Variables"
    ]
  },
  {
    "objectID": "docs/concurrency/condition-variable.html#why-predicate",
    "href": "docs/concurrency/condition-variable.html#why-predicate",
    "title": "Condition Variables",
    "section": "Why Predicate?",
    "text": "Why Predicate?\nCondition variables can have spurious wakeups. Always use a predicate:\n// BAD: can wake up when condition is still false\ncv.wait(lock);\nif (data_ready) { /* use data */ }\n\n// GOOD: rechecks condition after wakeup\ncv.wait(lock, []{ return data_ready; });\n// equivalent to:\nwhile (!data_ready) {\n    cv.wait(lock);\n}",
    "crumbs": [
      "Concurrency",
      "Condition Variables"
    ]
  },
  {
    "objectID": "docs/concurrency/condition-variable.html#notification",
    "href": "docs/concurrency/condition-variable.html#notification",
    "title": "Condition Variables",
    "section": "Notification",
    "text": "Notification\ncv.notify_one();  // wake one waiting thread\ncv.notify_all();  // wake all waiting threads",
    "crumbs": [
      "Concurrency",
      "Condition Variables"
    ]
  },
  {
    "objectID": "docs/concurrency/condition-variable.html#key-points",
    "href": "docs/concurrency/condition-variable.html#key-points",
    "title": "Condition Variables",
    "section": "Key Points",
    "text": "Key Points\n\nRequires unique_lock (not lock_guard)\nAlways use predicate form to handle spurious wakeups\nUnlock mutex before notifying (optimization)\nnotify_one for single consumer, notify_all for multiple",
    "crumbs": [
      "Concurrency",
      "Condition Variables"
    ]
  },
  {
    "objectID": "docs/concurrency/condition-variable.html#see-also",
    "href": "docs/concurrency/condition-variable.html#see-also",
    "title": "Condition Variables",
    "section": "See Also",
    "text": "See Also\n\nmutex - locks\nfuture-promise - one-shot signaling",
    "crumbs": [
      "Concurrency",
      "Condition Variables"
    ]
  },
  {
    "objectID": "docs/concurrency/async.html",
    "href": "docs/concurrency/async.html",
    "title": "std::async",
    "section": "",
    "text": "High-level asynchronous execution.",
    "crumbs": [
      "Concurrency",
      "std::async"
    ]
  },
  {
    "objectID": "docs/concurrency/async.html#basic-usage",
    "href": "docs/concurrency/async.html#basic-usage",
    "title": "std::async",
    "section": "Basic Usage",
    "text": "Basic Usage\n#include &lt;future&gt;\n\nstd::future&lt;int&gt; f = std::async([] {\n    return expensive_computation();\n});\n\n// Do other work...\n\nint result = f.get();  // blocks until ready",
    "crumbs": [
      "Concurrency",
      "std::async"
    ]
  },
  {
    "objectID": "docs/concurrency/async.html#launch-policies",
    "href": "docs/concurrency/async.html#launch-policies",
    "title": "std::async",
    "section": "Launch Policies",
    "text": "Launch Policies\n// async: run in new thread\nstd::future&lt;int&gt; f1 = std::async(std::launch::async, task);\n\n// deferred: run when get() is called (same thread)\nstd::future&lt;int&gt; f2 = std::async(std::launch::deferred, task);\n\n// default: implementation chooses (async | deferred)\nstd::future&lt;int&gt; f3 = std::async(task);",
    "crumbs": [
      "Concurrency",
      "std::async"
    ]
  },
  {
    "objectID": "docs/concurrency/async.html#gotcha-future-destruction",
    "href": "docs/concurrency/async.html#gotcha-future-destruction",
    "title": "std::async",
    "section": "Gotcha: Future Destruction",
    "text": "Gotcha: Future Destruction\nThe future from std::async blocks on destruction:\n// Each async blocks until complete!\nstd::async(std::launch::async, long_task);  // blocks here\nstd::async(std::launch::async, long_task);  // then blocks here\n// Total time: 2x long_task\n\n// Keep the futures to run in parallel\nauto f1 = std::async(std::launch::async, long_task);\nauto f2 = std::async(std::launch::async, long_task);\nf1.get();\nf2.get();\n// Total time: 1x long_task (parallel)",
    "crumbs": [
      "Concurrency",
      "std::async"
    ]
  },
  {
    "objectID": "docs/concurrency/async.html#hierarchy",
    "href": "docs/concurrency/async.html#hierarchy",
    "title": "std::async",
    "section": "Hierarchy",
    "text": "Hierarchy\nFrom high to low level:\nstd::async         - simplest, manages threading\n    ↓\nstd::packaged_task - wrap callable, get future\n    ↓\nstd::promise       - manual value setting",
    "crumbs": [
      "Concurrency",
      "std::async"
    ]
  },
  {
    "objectID": "docs/concurrency/async.html#key-points",
    "href": "docs/concurrency/async.html#key-points",
    "title": "std::async",
    "section": "Key Points",
    "text": "Key Points\n\nUse std::launch::async if you need parallelism\ndeferred runs lazily on get()\nDon’t discard the future (it will block!)\nFor fire-and-forget, use raw threads or thread pools\nNo built-in thread pool (use external library)",
    "crumbs": [
      "Concurrency",
      "std::async"
    ]
  },
  {
    "objectID": "docs/concurrency/async.html#see-also",
    "href": "docs/concurrency/async.html#see-also",
    "title": "std::async",
    "section": "See Also",
    "text": "See Also\n\nfuture-promise - lower-level primitives\nthreads - manual thread control",
    "crumbs": [
      "Concurrency",
      "std::async"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html",
    "href": "docs/compilation/inline.html",
    "title": "Inline",
    "section": "",
    "text": "Multiple definitions allowed across translation units.",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#inline-functions",
    "href": "docs/compilation/inline.html#inline-functions",
    "title": "Inline",
    "section": "Inline Functions",
    "text": "Inline Functions\n// In header file\ninline int square(int x) {\n    return x * x;\n}\nThe compiler may: 1. Replace call with function body (inlining) 2. Or keep as regular function call\nKey: definition can appear in multiple TUs without ODR violation.",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#inline-variables-c17",
    "href": "docs/compilation/inline.html#inline-variables-c17",
    "title": "Inline",
    "section": "Inline Variables (C++17)",
    "text": "Inline Variables (C++17)\n// In header file\ninline int counter = 0;\ninline const int config_value = 42;\ninline constexpr int compile_time = 100;\nAll translation units share the same variable.",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#constexpr-functions",
    "href": "docs/compilation/inline.html#constexpr-functions",
    "title": "Inline",
    "section": "constexpr Functions",
    "text": "constexpr Functions\nImplicitly inline:\nconstexpr int factorial(int n) {\n    return n &lt;= 1 ? 1 : n * factorial(n - 1);\n}\n// Can be in header, included multiple times",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#templates",
    "href": "docs/compilation/inline.html#templates",
    "title": "Inline",
    "section": "Templates",
    "text": "Templates\nTemplate definitions must be visible at instantiation, so they’re effectively inline:\n// In header file\ntemplate &lt;typename T&gt;\nT add(T a, T b) {\n    return a + b;\n}\n\ntemplate &lt;typename T&gt;\nconstexpr T pi = T(3.14159265358979L);",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#static-class-members",
    "href": "docs/compilation/inline.html#static-class-members",
    "title": "Inline",
    "section": "Static Class Members",
    "text": "Static Class Members\nclass Config {\npublic:\n    // Declaration only\n    static int value;\n\n    // Inline definition (C++17)\n    static inline int inline_value = 42;\n    static constexpr int const_value = 100; // implicitly inline\n};\n\n// In .cpp file (without inline)\nint Config::value = 0;",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#header-only-libraries",
    "href": "docs/compilation/inline.html#header-only-libraries",
    "title": "Inline",
    "section": "Header-Only Libraries",
    "text": "Header-Only Libraries\ninline enables header-only libraries:\n// mylib.hpp\ninline void helper() { /* ... */ }\ninline int global_counter = 0;\n\nclass MyClass {\n    // Member functions defined in class are implicitly inline\n    void method() { /* ... */ }\n};",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#key-points",
    "href": "docs/compilation/inline.html#key-points",
    "title": "Inline",
    "section": "Key Points",
    "text": "Key Points\n\ninline is about linkage, not performance\nMultiple definitions must be identical\nconstexpr functions are implicitly inline\nC++17 inline variables solve static member initialization\nTemplates are effectively inline",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/inline.html#see-also",
    "href": "docs/compilation/inline.html#see-also",
    "title": "Inline",
    "section": "See Also",
    "text": "See Also\n\nlinkage - internal vs external linkage\ntranslation-units - compilation units",
    "crumbs": [
      "Compilation",
      "Inline"
    ]
  },
  {
    "objectID": "docs/compilation/index.html",
    "href": "docs/compilation/index.html",
    "title": "Compilation",
    "section": "",
    "text": "C++ build model and linkage.",
    "crumbs": [
      "Compilation"
    ]
  },
  {
    "objectID": "docs/compilation/index.html#topics",
    "href": "docs/compilation/index.html#topics",
    "title": "Compilation",
    "section": "Topics",
    "text": "Topics\n\ntranslation-units - Compilation units and ODR\nlinkage - Internal and external linkage\ninline - Inline functions and variables",
    "crumbs": [
      "Compilation"
    ]
  },
  {
    "objectID": "docs/classes/raii.html",
    "href": "docs/classes/raii.html",
    "title": "RAII",
    "section": "",
    "text": "Resource Acquisition Is Initialization.",
    "crumbs": [
      "Classes",
      "RAII"
    ]
  },
  {
    "objectID": "docs/classes/raii.html#the-pattern",
    "href": "docs/classes/raii.html#the-pattern",
    "title": "RAII",
    "section": "The Pattern",
    "text": "The Pattern\n\nAcquire resource in constructor\nUse resource through object\nRelease resource in destructor (automatic)\n\nvoid writeToFile(const std::string& message) {\n    static std::mutex mutex;\n\n    // RAII: lock acquired in constructor\n    std::lock_guard&lt;std::mutex&gt; lock(mutex);\n\n    // RAII: file opened in constructor\n    std::ofstream file(\"example.txt\");\n    if (!file.is_open()) {\n        throw std::runtime_error(\"unable to open file\");\n    }\n\n    file &lt;&lt; message &lt;&lt; std::endl;\n\n    // Automatic cleanup when scope exits:\n    // 1. file destructor closes file\n    // 2. lock destructor releases mutex\n    // Even if exception is thrown!\n}",
    "crumbs": [
      "Classes",
      "RAII"
    ]
  },
  {
    "objectID": "docs/classes/raii.html#why-raii",
    "href": "docs/classes/raii.html#why-raii",
    "title": "RAII",
    "section": "Why RAII?",
    "text": "Why RAII?\nWithout RAII (error-prone):\nvoid dangerous() {\n    int* p = new int[100];\n    // ... code that might throw ...\n    delete[] p;  // might never run!\n}\nWith RAII (safe):\nvoid safe() {\n    std::unique_ptr&lt;int[]&gt; p(new int[100]);\n    // ... code that might throw ...\n    // p automatically deleted\n}",
    "crumbs": [
      "Classes",
      "RAII"
    ]
  },
  {
    "objectID": "docs/classes/raii.html#raii-wrappers-in-standard-library",
    "href": "docs/classes/raii.html#raii-wrappers-in-standard-library",
    "title": "RAII",
    "section": "RAII Wrappers in Standard Library",
    "text": "RAII Wrappers in Standard Library\n\n\n\nResource\nRAII Wrapper\n\n\n\n\nDynamic memory\nunique_ptr, shared_ptr\n\n\nMutex\nlock_guard, unique_lock\n\n\nFile\nfstream\n\n\nThread\njthread (C++20)",
    "crumbs": [
      "Classes",
      "RAII"
    ]
  },
  {
    "objectID": "docs/classes/raii.html#custom-raii",
    "href": "docs/classes/raii.html#custom-raii",
    "title": "RAII",
    "section": "Custom RAII",
    "text": "Custom RAII\nclass FileHandle {\n    FILE* file;\npublic:\n    FileHandle(const char* name) : file(fopen(name, \"r\")) {\n        if (!file) throw std::runtime_error(\"open failed\");\n    }\n    ~FileHandle() {\n        if (file) fclose(file);\n    }\n    // Delete copy (or implement properly)\n    FileHandle(const FileHandle&) = delete;\n    FileHandle& operator=(const FileHandle&) = delete;\n};",
    "crumbs": [
      "Classes",
      "RAII"
    ]
  },
  {
    "objectID": "docs/classes/raii.html#key-points",
    "href": "docs/classes/raii.html#key-points",
    "title": "RAII",
    "section": "Key Points",
    "text": "Key Points\n\nTie resource lifetime to object lifetime\nDestructor guarantees cleanup (even with exceptions)\nPrefer RAII wrappers over manual resource management\nFollow Rule of 5 for custom RAII types\nCore principle of modern C++",
    "crumbs": [
      "Classes",
      "RAII"
    ]
  },
  {
    "objectID": "docs/classes/raii.html#see-also",
    "href": "docs/classes/raii.html#see-also",
    "title": "RAII",
    "section": "See Also",
    "text": "See Also\n\nallocation - memory management\nconstructors - acquisition\ndestructors - release",
    "crumbs": [
      "Classes",
      "RAII"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html",
    "href": "docs/classes/virtual.html",
    "title": "Virtual Functions",
    "section": "",
    "text": "Runtime polymorphism through dynamic dispatch.",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#basic-virtual-functions",
    "href": "docs/classes/virtual.html#basic-virtual-functions",
    "title": "Virtual Functions",
    "section": "Basic Virtual Functions",
    "text": "Basic Virtual Functions\nstruct Base {\n    virtual void print() const {\n        std::cout &lt;&lt; \"Base\\n\";\n    }\n    virtual ~Base() = default;\n};\n\nstruct Derived : Base {\n    void print() const override {\n        std::cout &lt;&lt; \"Derived\\n\";\n    }\n};\n\nvoid call(Base& b) { b.print(); }\n\nBase b;\nDerived d;\ncall(b);  // \"Base\"\ncall(d);  // \"Derived\" (dynamic dispatch)",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#override-and-final",
    "href": "docs/classes/virtual.html#override-and-final",
    "title": "Virtual Functions",
    "section": "override and final",
    "text": "override and final\nstruct Base {\n    virtual void f1(int i = 8) {}\n    virtual void f2() {}\n};\n\nstruct Derived final : Base {  // final: cannot be inherited\n    void f1(int i = 7) override final {}  // override + final\n    // override: ensures it's actually overriding\n    // final: prevents further overriding\n};",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#default-arguments-warning",
    "href": "docs/classes/virtual.html#default-arguments-warning",
    "title": "Virtual Functions",
    "section": "Default Arguments Warning",
    "text": "Default Arguments Warning\nBase& b = derived;\nb.f1();  // Calls Derived::f1 with Base's default (8)!\nDefault arguments come from the static type, not dynamic type.",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#virtual-table-vtable",
    "href": "docs/classes/virtual.html#virtual-table-vtable",
    "title": "Virtual Functions",
    "section": "Virtual Table (vtable)",
    "text": "Virtual Table (vtable)\n/*\n     Object             vtable\n   +--------+        +--------+\n   |  vptr  | -----&gt; |  print |  -&gt; Base::print or Derived::print\n   +--------+        +--------+\n   |  data  |        |  f1    |\n   +--------+        +--------+\n                     |  f2    |\n                     +--------+\n*/\nEach class with virtual functions has a vtable. Objects have a hidden vptr pointing to their class’s vtable.",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#pure-virtual-abstract-classes",
    "href": "docs/classes/virtual.html#pure-virtual-abstract-classes",
    "title": "Virtual Functions",
    "section": "Pure Virtual (Abstract Classes)",
    "text": "Pure Virtual (Abstract Classes)\n// Interface: only pure virtuals\nstruct Interface {\n    virtual void f() = 0;\n    virtual ~Interface() = default;\n};\n\n// Abstract: at least one pure virtual\nstruct Abstract {\n    int data;\n    virtual void f() = 0;\n};\n\n// Cannot instantiate Interface or Abstract\n// Interface i;  // ERROR\n// Abstract a;   // ERROR",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#crtp-static-polymorphism",
    "href": "docs/classes/virtual.html#crtp-static-polymorphism",
    "title": "Virtual Functions",
    "section": "CRTP (Static Polymorphism)",
    "text": "CRTP (Static Polymorphism)\nCuriously Recurring Template Pattern - compile-time polymorphism:\ntemplate &lt;typename T&gt;\nstruct Base {\n    void interface() {\n        static_cast&lt;T*&gt;(this)-&gt;implementation();\n    }\n};\n\nstruct Derived : Base&lt;Derived&gt; {\n    void implementation() { /* ... */ }\n};\nNo vtable overhead, but no runtime polymorphism.",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#key-points",
    "href": "docs/classes/virtual.html#key-points",
    "title": "Virtual Functions",
    "section": "Key Points",
    "text": "Key Points\n\nvirtual enables runtime polymorphism\nAlways use override when overriding\nUse final to prevent further inheritance/overriding\nDefault arguments bind at compile time (use static type)\nVirtual destructor required for polymorphic base classes\nCRTP provides compile-time polymorphism",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/virtual.html#see-also",
    "href": "docs/classes/virtual.html#see-also",
    "title": "Virtual Functions",
    "section": "See Also",
    "text": "See Also\n\ninheritance - class hierarchies\nobject-layout - memory layout with vtables\nraii - combining with RAII",
    "crumbs": [
      "Classes",
      "Virtual Functions"
    ]
  },
  {
    "objectID": "docs/classes/destructors.html",
    "href": "docs/classes/destructors.html",
    "title": "Destructors",
    "section": "",
    "text": "Object cleanup when lifetime ends.",
    "crumbs": [
      "Classes",
      "Destructors"
    ]
  },
  {
    "objectID": "docs/classes/destructors.html#basic-destructor",
    "href": "docs/classes/destructors.html#basic-destructor",
    "title": "Destructors",
    "section": "Basic Destructor",
    "text": "Basic Destructor\nclass Resource {\n    int* data;\npublic:\n    Resource() : data(new int[100]) {}\n    ~Resource() {\n        delete[] data; // cleanup\n    }\n};",
    "crumbs": [
      "Classes",
      "Destructors"
    ]
  },
  {
    "objectID": "docs/classes/destructors.html#virtual-destructor",
    "href": "docs/classes/destructors.html#virtual-destructor",
    "title": "Destructors",
    "section": "Virtual Destructor",
    "text": "Virtual Destructor\nRequired when deleting derived objects through base pointer:\nstruct Base {\n    virtual ~Base() { /* cleanup Base */ }\n};\n\nstruct Derived : Base {\n    ~Derived() { /* cleanup Derived */ }\n};\n\nBase* ptr = new Derived;\ndelete ptr; // Calls ~Derived() then ~Base()\nWithout virtual, only ~Base() runs (undefined behavior).",
    "crumbs": [
      "Classes",
      "Destructors"
    ]
  },
  {
    "objectID": "docs/classes/destructors.html#destruction-order",
    "href": "docs/classes/destructors.html#destruction-order",
    "title": "Destructors",
    "section": "Destruction Order",
    "text": "Destruction Order\nstruct A { ~A() { std::cout &lt;&lt; \"A\"; } };\nstruct B : A { ~B() { std::cout &lt;&lt; \"B\"; } };\nstruct C : B { ~C() { std::cout &lt;&lt; \"C\"; } };\n\nC c;\n// Output when c goes out of scope: \"CBA\"\n// Destruction is reverse of construction",
    "crumbs": [
      "Classes",
      "Destructors"
    ]
  },
  {
    "objectID": "docs/classes/destructors.html#when-destructors-run",
    "href": "docs/classes/destructors.html#when-destructors-run",
    "title": "Destructors",
    "section": "When Destructors Run",
    "text": "When Destructors Run\n\nLocal variables: when scope exits\nHeap objects: when delete is called\nClass members: after containing class destructor body\nGlobal/static: at program termination",
    "crumbs": [
      "Classes",
      "Destructors"
    ]
  },
  {
    "objectID": "docs/classes/destructors.html#key-points",
    "href": "docs/classes/destructors.html#key-points",
    "title": "Destructors",
    "section": "Key Points",
    "text": "Key Points\n\nAlways make destructor virtual if class has virtual functions\nDestructor should never throw exceptions\nRuns in reverse order of construction\nCalled automatically when object goes out of scope",
    "crumbs": [
      "Classes",
      "Destructors"
    ]
  },
  {
    "objectID": "docs/classes/destructors.html#see-also",
    "href": "docs/classes/destructors.html#see-also",
    "title": "Destructors",
    "section": "See Also",
    "text": "See Also\n\nconstructors - object creation\nraii - resource management pattern",
    "crumbs": [
      "Classes",
      "Destructors"
    ]
  },
  {
    "objectID": "docs/classes/basics.html",
    "href": "docs/classes/basics.html",
    "title": "Class Basics",
    "section": "",
    "text": "Fundamental class concepts in C++.",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#member-functions",
    "href": "docs/classes/basics.html#member-functions",
    "title": "Class Basics",
    "section": "Member Functions",
    "text": "Member Functions\nEvery member function has an implicit this parameter:\nclass A {\npublic:\n    void foo(int x) {} // Actually: void foo(A* this, int x)\n};\n\nA a;\na.foo(1); // Equivalent to A::foo(&a, 1)\n\nthis Keyword\nstruct A {\n    int x;\n    void f(int x) { this-&gt;x = x; }  // disambiguate member from parameter\n    const A& g() { return *this; }  // return reference to self\n};\n\n\nconst Member Functions\nstruct C {\n    int x = 3;\n    int* p;\n\n    // const member function - cannot modify logical state\n    int get() const {\n        // x = 4;       // error: can't modify member\n        // p = nullptr; // error: can't modify pointer\n        p[0] = 1;       // ok: modifying what p points to\n        return x;\n    }\n\n    // non-const overload\n    int get() { return x; }\n};\n\n\nmutable Keyword\nAllows modification in const context (useful for caching):\nstruct D {\n    mutable int cache = -1;\n\n    int compute() const {\n        if (cache == -1) {\n            // expensive computation\n            cache = 42;  // ok: mutable\n        }\n        return cache;\n    }\n};\n\n\nstatic Members\nstruct B {\n    // static member function - can only access static members\n    static int f() { return 0; }\n\n    // static constants - can initialize in class\n    static const int x = 1;\n    static constexpr int y = 2;\n    static constexpr float z = 1.2f;\n\n    // static mutable - must define outside class (or use inline)\n    static int a;            // declaration\n    static inline int b = 1; // C++17: inline allows initialization\n};\nint B::a = 1; // definition outside class\n\n\nusing to Change Access\nstruct E : C {\n    using value_type = int;  // type alias\n\n  private:\n    using C::x;  // change x from public to private\n};",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#access-specifiers",
    "href": "docs/classes/basics.html#access-specifiers",
    "title": "Class Basics",
    "section": "Access Specifiers",
    "text": "Access Specifiers\nclass Base {\npublic:\n    int a;    // accessible everywhere\nprotected:\n    int b;    // accessible in class and derived classes\nprivate:\n    int c;    // accessible only in this class\n};",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#inheritance-access",
    "href": "docs/classes/basics.html#inheritance-access",
    "title": "Class Basics",
    "section": "Inheritance Access",
    "text": "Inheritance Access\nclass PublicDerived : public Base {\n    // a is public, b is protected, c is inaccessible\n};\n\nclass ProtectedDerived : protected Base {\n    // a is protected, b is protected, c is inaccessible\n};\n\nclass PrivateDerived : private Base {\n    // a is private, b is private, c is inaccessible\n};",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#constructiondestruction-order",
    "href": "docs/classes/basics.html#constructiondestruction-order",
    "title": "Class Basics",
    "section": "Construction/Destruction Order",
    "text": "Construction/Destruction Order\nstruct Base {};\nstruct Derived : Base {};\nstruct MoreDerived : Derived {};\n\nMoreDerived obj;\n// Construction: Base -&gt; Derived -&gt; MoreDerived\n// Destruction:  MoreDerived -&gt; Derived -&gt; Base",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#virtual-inheritance-diamond-problem",
    "href": "docs/classes/basics.html#virtual-inheritance-diamond-problem",
    "title": "Class Basics",
    "section": "Virtual Inheritance (Diamond Problem)",
    "text": "Virtual Inheritance (Diamond Problem)\nstruct A { void f() {} };\nstruct B : virtual A {};  // share A\nstruct C : virtual A {};  // share A\nstruct D : B, C {};       // only one A subobject\n\n//     A\n//    / \\\n//   B   C   (Diamond)\n//    \\ /\n//     D\n\nD d;\nd.f(); // Unambiguous: only one A::f()",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#member-function-overloading",
    "href": "docs/classes/basics.html#member-function-overloading",
    "title": "Class Basics",
    "section": "Member Function Overloading",
    "text": "Member Function Overloading\nCan overload on qualifiers (8 combinations):\nstruct A {\n    void f() & {}              // lvalue\n    void f() && {}             // rvalue\n    void f() const & {}        // const lvalue\n    void f() const && {}       // const rvalue\n    void f() volatile & {}     // volatile lvalue\n    void f() volatile && {}    // volatile rvalue\n    void f() const volatile & {}\n    void f() const volatile && {}\n};",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#key-points",
    "href": "docs/classes/basics.html#key-points",
    "title": "Class Basics",
    "section": "Key Points",
    "text": "Key Points\n\nthis is an implicit pointer to the current object\nUse public inheritance for is-a relationships\nVirtual inheritance solves the diamond problem\nConstruction is base-first, destruction is derived-first",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/basics.html#see-also",
    "href": "docs/classes/basics.html#see-also",
    "title": "Class Basics",
    "section": "See Also",
    "text": "See Also\n\nconstructors - constructor types\ninheritance - inheritance details\nvirtual - virtual functions",
    "crumbs": [
      "Classes",
      "Class Basics"
    ]
  },
  {
    "objectID": "docs/classes/index.html",
    "href": "docs/classes/index.html",
    "title": "Classes",
    "section": "",
    "text": "Object-oriented programming and the C++ object model.",
    "crumbs": [
      "Classes"
    ]
  },
  {
    "objectID": "docs/classes/index.html#topics",
    "href": "docs/classes/index.html#topics",
    "title": "Classes",
    "section": "Topics",
    "text": "Topics\n\nbasics - Member functions, access specifiers, inheritance\nconstructors - Default, copy, move, delegating constructors\ndestructors - Cleanup and virtual destructors\ncopy-move - Copy/move semantics, Rule of Five\ninheritance - Hierarchies, casting, RTTI\nvirtual - Virtual functions, vtables, polymorphism\noperators - Operator overloading\nobject-layout - Aggregate, trivial, standard layout\nraii - Resource management pattern",
    "crumbs": [
      "Classes"
    ]
  },
  {
    "objectID": "docs/patterns/creational/factory.html",
    "href": "docs/patterns/creational/factory.html",
    "title": "Factory Pattern",
    "section": "",
    "text": "Create objects without exposing creation logic.",
    "crumbs": [
      "Patterns",
      "Factory Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/factory.html#static-factory-methods",
    "href": "docs/patterns/creational/factory.html#static-factory-methods",
    "title": "Factory Pattern",
    "section": "Static Factory Methods",
    "text": "Static Factory Methods\nclass Point {\n    float x, y;\n    Point(float x, float y) : x(x), y(y) {}\n\npublic:\n    // Named constructors\n    static Point Cartesian(float x, float y) {\n        return {x, y};\n    }\n    static Point Polar(float r, float theta) {\n        return {r * cos(theta), r * sin(theta)};\n    }\n};\n\nauto p1 = Point::Cartesian(3, 4);\nauto p2 = Point::Polar(5, 0.927);",
    "crumbs": [
      "Patterns",
      "Factory Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/factory.html#dedicated-factory-class",
    "href": "docs/patterns/creational/factory.html#dedicated-factory-class",
    "title": "Factory Pattern",
    "section": "Dedicated Factory Class",
    "text": "Dedicated Factory Class\nclass Point {\npublic:\n    Point(float x, float y);\n};\n\nclass PointFactory {\npublic:\n    static Point Cartesian(float x, float y) { return {x, y}; }\n    static Point Polar(float r, float theta) {\n        return {r * cos(theta), r * sin(theta)};\n    }\n};\n\nauto p = PointFactory::Polar(5, 0.927);",
    "crumbs": [
      "Patterns",
      "Factory Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/factory.html#inner-factory",
    "href": "docs/patterns/creational/factory.html#inner-factory",
    "title": "Factory Pattern",
    "section": "Inner Factory",
    "text": "Inner Factory\nclass Point {\n    Point(float x, float y);\n\npublic:\n    class Factory {\n    public:\n        static Point Cartesian(float x, float y) { return {x, y}; }\n        static Point Polar(float r, float theta);\n    };\n};\n\nauto p = Point::Factory::Cartesian(3, 4);",
    "crumbs": [
      "Patterns",
      "Factory Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/factory.html#abstract-factory",
    "href": "docs/patterns/creational/factory.html#abstract-factory",
    "title": "Factory Pattern",
    "section": "Abstract Factory",
    "text": "Abstract Factory\nCreate families of related objects:\nclass HotDrink {\npublic:\n    virtual void prepare(int volume) = 0;\n};\n\nclass HotDrinkFactory {\npublic:\n    virtual std::unique_ptr&lt;HotDrink&gt; make() = 0;\n};\n\nclass TeaFactory : public HotDrinkFactory {\n    std::unique_ptr&lt;HotDrink&gt; make() override {\n        return std::make_unique&lt;Tea&gt;();\n    }\n};\n\nclass DrinkFactory {\n    std::map&lt;std::string, std::unique_ptr&lt;HotDrinkFactory&gt;&gt; factories;\npublic:\n    DrinkFactory() {\n        factories[\"tea\"] = std::make_unique&lt;TeaFactory&gt;();\n        factories[\"coffee\"] = std::make_unique&lt;CoffeeFactory&gt;();\n    }\n    std::unique_ptr&lt;HotDrink&gt; make(const std::string& name) {\n        return factories[name]-&gt;make();\n    }\n};",
    "crumbs": [
      "Patterns",
      "Factory Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/factory.html#key-points",
    "href": "docs/patterns/creational/factory.html#key-points",
    "title": "Factory Pattern",
    "section": "Key Points",
    "text": "Key Points\n\nFactory encapsulates object creation\nStatic methods: simple, no extra class\nAbstract factory: families of related objects\nEnables dependency injection\nHides implementation details",
    "crumbs": [
      "Patterns",
      "Factory Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/factory.html#see-also",
    "href": "docs/patterns/creational/factory.html#see-also",
    "title": "Factory Pattern",
    "section": "See Also",
    "text": "See Also\n\nbuilder - step-by-step construction\nprototype - cloning objects",
    "crumbs": [
      "Patterns",
      "Factory Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/builder.html",
    "href": "docs/patterns/creational/builder.html",
    "title": "Builder Pattern",
    "section": "",
    "text": "Construct complex objects step by step.",
    "crumbs": [
      "Patterns",
      "Builder Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/builder.html#fluent-builder",
    "href": "docs/patterns/creational/builder.html#fluent-builder",
    "title": "Builder Pattern",
    "section": "Fluent Builder",
    "text": "Fluent Builder\nclass Person {\n    std::string street, city, company, position;\n    int income{0};\n\npublic:\n    static PersonBuilder create();\n    friend class PersonBuilder;\n    friend class PersonAddressBuilder;\n    friend class PersonJobBuilder;\n};\n\nclass PersonBuilderBase {\nprotected:\n    Person& person;\npublic:\n    PersonBuilderBase(Person& p) : person(p) {}\n    PersonAddressBuilder lives() const;\n    PersonJobBuilder works() const;\n    operator Person() { return std::move(person); }\n};\n\nclass PersonAddressBuilder : public PersonBuilderBase {\npublic:\n    PersonAddressBuilder& at(std::string street) {\n        person.street = street;\n        return *this;\n    }\n    PersonAddressBuilder& in(std::string city) {\n        person.city = city;\n        return *this;\n    }\n};\n\nclass PersonJobBuilder : public PersonBuilderBase {\npublic:\n    PersonJobBuilder& at(std::string company) {\n        person.company = company;\n        return *this;\n    }\n    PersonJobBuilder& earning(int income) {\n        person.income = income;\n        return *this;\n    }\n};",
    "crumbs": [
      "Patterns",
      "Builder Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/builder.html#usage",
    "href": "docs/patterns/creational/builder.html#usage",
    "title": "Builder Pattern",
    "section": "Usage",
    "text": "Usage\nPerson p = Person::create()\n    .lives()\n        .at(\"123 Main St\")\n        .in(\"New York\")\n    .works()\n        .at(\"Google\")\n        .earning(150000);",
    "crumbs": [
      "Patterns",
      "Builder Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/builder.html#simple-builder",
    "href": "docs/patterns/creational/builder.html#simple-builder",
    "title": "Builder Pattern",
    "section": "Simple Builder",
    "text": "Simple Builder\nclass HtmlBuilder {\n    HtmlElement root;\npublic:\n    HtmlBuilder(std::string root_name) {\n        root.name = root_name;\n    }\n    HtmlBuilder& add_child(std::string name, std::string text) {\n        root.elements.push_back({name, text});\n        return *this;  // fluent interface\n    }\n    std::string str() const { return root.str(); }\n};\n\nauto html = HtmlBuilder(\"ul\")\n    .add_child(\"li\", \"Item 1\")\n    .add_child(\"li\", \"Item 2\")\n    .str();",
    "crumbs": [
      "Patterns",
      "Builder Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/builder.html#key-points",
    "href": "docs/patterns/creational/builder.html#key-points",
    "title": "Builder Pattern",
    "section": "Key Points",
    "text": "Key Points\n\nSeparates construction from representation\nFluent interface via return *this\nMultiple builders for different aspects\nCan switch between builders mid-construction\nGreat for objects with many optional parameters",
    "crumbs": [
      "Patterns",
      "Builder Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/creational/builder.html#see-also",
    "href": "docs/patterns/creational/builder.html#see-also",
    "title": "Builder Pattern",
    "section": "See Also",
    "text": "See Also\n\nfactory - simpler creation\nprototype - cloning existing objects",
    "crumbs": [
      "Patterns",
      "Builder Pattern"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html",
    "href": "docs/patterns/structural/pimpl.html",
    "title": "Pimpl Idiom",
    "section": "",
    "text": "Hide implementation details to reduce compile dependencies.",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html#the-problem",
    "href": "docs/patterns/structural/pimpl.html#the-problem",
    "title": "Pimpl Idiom",
    "section": "The Problem",
    "text": "The Problem\n// widget.hpp - changes here recompile all users\nclass Widget {\n    ComplexType member1;  // must include ComplexType.hpp\n    AnotherType member2;  // must include AnotherType.hpp\npublic:\n    void draw();\n};\nEvery file including widget.hpp depends on ComplexType.hpp and AnotherType.hpp.",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html#the-solution",
    "href": "docs/patterns/structural/pimpl.html#the-solution",
    "title": "Pimpl Idiom",
    "section": "The Solution",
    "text": "The Solution\n// widget.hpp - minimal dependencies\nclass Widget {\n    class Impl;                    // forward declaration\n    std::unique_ptr&lt;Impl&gt; pImpl;   // pointer to implementation\n\npublic:\n    Widget();\n    ~Widget();\n    void draw();\n};\n// widget.cpp - implementation hidden here\n#include \"widget.hpp\"\n#include \"ComplexType.hpp\"\n#include \"AnotherType.hpp\"\n\nclass Widget::Impl {\n    ComplexType member1;\n    AnotherType member2;\npublic:\n    void draw() { /* ... */ }\n};\n\nWidget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()) {}\nWidget::~Widget() = default;  // must be in .cpp for unique_ptr\nvoid Widget::draw() { pImpl-&gt;draw(); }",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html#template-pimpl",
    "href": "docs/patterns/structural/pimpl.html#template-pimpl",
    "title": "Pimpl Idiom",
    "section": "Template Pimpl",
    "text": "Template Pimpl\ntemplate &lt;typename Impl&gt;\nclass Widget {\n    std::unique_ptr&lt;Impl&gt; pImpl;\npublic:\n    Widget() : pImpl(std::make_unique&lt;Impl&gt;()) {}\n    ~Widget() = default;\n    void draw() { pImpl-&gt;draw(); }\n};\n\nclass DefaultImpl {\npublic:\n    void draw() { std::cout &lt;&lt; \"Default\\n\"; }\n};\n\nclass FancyImpl {\npublic:\n    void draw() { std::cout &lt;&lt; \"Fancy\\n\"; }\n};\n\nWidget&lt;DefaultImpl&gt; w1;\nWidget&lt;FancyImpl&gt; w2;",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html#benefits",
    "href": "docs/patterns/structural/pimpl.html#benefits",
    "title": "Pimpl Idiom",
    "section": "Benefits",
    "text": "Benefits\n\nReduced compile time: Changes to Impl don’t recompile users\nBinary compatibility: Can change Impl without breaking ABI\nHidden implementation: Users can’t access private details\nCleaner headers: No need to include implementation headers",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html#costs",
    "href": "docs/patterns/structural/pimpl.html#costs",
    "title": "Pimpl Idiom",
    "section": "Costs",
    "text": "Costs\n\nExtra indirection (pointer dereference)\nExtra allocation (heap for Impl)\nMust define destructor in .cpp",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html#key-points",
    "href": "docs/patterns/structural/pimpl.html#key-points",
    "title": "Pimpl Idiom",
    "section": "Key Points",
    "text": "Key Points\n\nForward declare Impl class in header\nDefine Impl in .cpp file\nDestructor must be in .cpp (for unique_ptr)\nCommon in library interfaces\nTrade-off: compile time vs runtime performance",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/structural/pimpl.html#see-also",
    "href": "docs/patterns/structural/pimpl.html#see-also",
    "title": "Pimpl Idiom",
    "section": "See Also",
    "text": "See Also\n\nadapter - interface conversion\nlinkage - translation units",
    "crumbs": [
      "Patterns",
      "Pimpl Idiom"
    ]
  },
  {
    "objectID": "docs/patterns/index.html",
    "href": "docs/patterns/index.html",
    "title": "Design Patterns",
    "section": "",
    "text": "Software design patterns in C++.",
    "crumbs": [
      "Patterns"
    ]
  },
  {
    "objectID": "docs/patterns/index.html#principles",
    "href": "docs/patterns/index.html#principles",
    "title": "Design Patterns",
    "section": "Principles",
    "text": "Principles\n\nsolid - SOLID principles",
    "crumbs": [
      "Patterns"
    ]
  },
  {
    "objectID": "docs/patterns/index.html#creational-patterns",
    "href": "docs/patterns/index.html#creational-patterns",
    "title": "Design Patterns",
    "section": "Creational Patterns",
    "text": "Creational Patterns\n\ncreational/factory - Object creation\ncreational/builder - Step-by-step construction\ncreational/singleton - Single instance\ncreational/prototype - Clone objects\ncreational/multiton - Named instances",
    "crumbs": [
      "Patterns"
    ]
  },
  {
    "objectID": "docs/patterns/index.html#structural-patterns",
    "href": "docs/patterns/index.html#structural-patterns",
    "title": "Design Patterns",
    "section": "Structural Patterns",
    "text": "Structural Patterns\n\nstructural/adapter - Interface conversion\nstructural/pimpl - Implementation hiding",
    "crumbs": [
      "Patterns"
    ]
  },
  {
    "objectID": "docs/stdlib/numeric.html",
    "href": "docs/stdlib/numeric.html",
    "title": "Numeric Utilities",
    "section": "",
    "text": "Math functions and numeric limits.",
    "crumbs": [
      "Standard Library",
      "Numeric Utilities"
    ]
  },
  {
    "objectID": "docs/stdlib/numeric.html#math-functions",
    "href": "docs/stdlib/numeric.html#math-functions",
    "title": "Numeric Utilities",
    "section": "Math Functions",
    "text": "Math Functions\n#include &lt;cmath&gt;\n\nauto x = std::exp2(3); // 2^3 = 8\nauto y = std::log2(8); // log2(8) = 3",
    "crumbs": [
      "Standard Library",
      "Numeric Utilities"
    ]
  },
  {
    "objectID": "docs/stdlib/numeric.html#numeric-limits",
    "href": "docs/stdlib/numeric.html#numeric-limits",
    "title": "Numeric Utilities",
    "section": "Numeric Limits",
    "text": "Numeric Limits\n#include &lt;limits&gt;\n\ntemplate &lt;typename T&gt;\nT get_max() {\n    return std::numeric_limits&lt;T&gt;::max();\n}\n\ntemplate &lt;typename T&gt;\nT get_min() {\n    return std::numeric_limits&lt;T&gt;::min();\n}\n\ntemplate &lt;typename T&gt;\nT get_lowest() {\n    // For floating point: most negative value (e.g., -infinity)\n    return std::numeric_limits&lt;T&gt;::lowest();\n}\n\ntemplate &lt;typename T&gt;\nT get_epsilon() {\n    // The machine epsilon\n    return std::numeric_limits&lt;T&gt;::epsilon();\n}",
    "crumbs": [
      "Standard Library",
      "Numeric Utilities"
    ]
  },
  {
    "objectID": "docs/stdlib/numeric.html#machine-epsilon",
    "href": "docs/stdlib/numeric.html#machine-epsilon",
    "title": "Numeric Utilities",
    "section": "Machine Epsilon",
    "text": "Machine Epsilon\nThe difference between 1 and the next larger floating point number:\n// Interval machine epsilon (not relative machine epsilon)\n// - interval machine epsilon = 2 * relative machine epsilon\n// - interval machine epsilon = ulp of 1.0\n\n// float: approx 1.19e-7\nstd::numeric_limits&lt;float&gt;::epsilon();   // 0.00000011920928955078125\n\n// double: approx 2.22e-16\nstd::numeric_limits&lt;double&gt;::epsilon();  // 0.00000000000000022204460492503131",
    "crumbs": [
      "Standard Library",
      "Numeric Utilities"
    ]
  },
  {
    "objectID": "docs/stdlib/numeric.html#lowest-vs-min",
    "href": "docs/stdlib/numeric.html#lowest-vs-min",
    "title": "Numeric Utilities",
    "section": "Lowest vs Min",
    "text": "Lowest vs Min\n// For integers: min() == lowest()\n// For floats: min() is smallest positive, lowest() is most negative\n\nstd::numeric_limits&lt;float&gt;::min();     // ~1.17e-38 (smallest positive)\nstd::numeric_limits&lt;float&gt;::lowest();  // ~-3.40e+38 (most negative)",
    "crumbs": [
      "Standard Library",
      "Numeric Utilities"
    ]
  },
  {
    "objectID": "docs/stdlib/numeric.html#key-points",
    "href": "docs/stdlib/numeric.html#key-points",
    "title": "Numeric Utilities",
    "section": "Key Points",
    "text": "Key Points\n\nmax() - largest finite value\nmin() - smallest positive value (floats) or most negative (integers)\nlowest() - most negative finite value\nepsilon() - machine precision for floating point\nUse &lt;cmath&gt; for math functions, &lt;limits&gt; for numeric limits",
    "crumbs": [
      "Standard Library",
      "Numeric Utilities"
    ]
  },
  {
    "objectID": "docs/stdlib/numeric.html#see-also",
    "href": "docs/stdlib/numeric.html#see-also",
    "title": "Numeric Utilities",
    "section": "See Also",
    "text": "See Also\n\ntypes - fundamental types",
    "crumbs": [
      "Standard Library",
      "Numeric Utilities"
    ]
  },
  {
    "objectID": "docs/stdlib/functional.html",
    "href": "docs/stdlib/functional.html",
    "title": "std::function and Functional",
    "section": "",
    "text": "Function wrappers, binding, and invocation.",
    "crumbs": [
      "Standard Library",
      "std::function and Functional"
    ]
  },
  {
    "objectID": "docs/stdlib/functional.html#stdfunction",
    "href": "docs/stdlib/functional.html#stdfunction",
    "title": "std::function and Functional",
    "section": "std::function",
    "text": "std::function\nPolymorphic function wrapper:\n#include &lt;functional&gt;\n\n// Store any callable with matching signature\nstd::function&lt;int(int, int)&gt; f;\n\nf = [](int a, int b) { return a + b; };  // lambda\nf = add;                                   // function pointer\nf = Functor{};                            // functor\n\nint result = f(2, 3);",
    "crumbs": [
      "Standard Library",
      "std::function and Functional"
    ]
  },
  {
    "objectID": "docs/stdlib/functional.html#stdbind",
    "href": "docs/stdlib/functional.html#stdbind",
    "title": "std::function and Functional",
    "section": "std::bind",
    "text": "std::bind\nBind arguments to a callable:\nvoid foo(int a, int b, int c, int d, int e);\n\n// Bind all arguments\nauto f1 = std::bind(foo, 1, 2, 3, 4, 5);\nf1(); // calls foo(1, 2, 3, 4, 5)\n\n// Bind with placeholders\nusing namespace std::placeholders;\nauto f2 = std::bind(foo, 1, _3, 5, _2, _1);\nf2(2, 3, 4); // calls foo(1, 4, 5, 3, 2)",
    "crumbs": [
      "Standard Library",
      "std::function and Functional"
    ]
  },
  {
    "objectID": "docs/stdlib/functional.html#stdinvoke",
    "href": "docs/stdlib/functional.html#stdinvoke",
    "title": "std::function and Functional",
    "section": "std::invoke",
    "text": "std::invoke\nUniform call syntax for any callable:\n#include &lt;functional&gt;\n\nint add(int a, int b) { return a + b; }\n\nstruct Multiply {\n    int operator()(int a, int b) const { return a * b; }\n};\n\nstd::invoke(add, 1, 2);           // function\nstd::invoke(Multiply{}, 3, 4);    // functor\nstd::invoke([](int a, int b) { return a - b; }, 5, 6); // lambda",
    "crumbs": [
      "Standard Library",
      "std::function and Functional"
    ]
  },
  {
    "objectID": "docs/stdlib/functional.html#stdmem_fn",
    "href": "docs/stdlib/functional.html#stdmem_fn",
    "title": "std::function and Functional",
    "section": "std::mem_fn",
    "text": "std::mem_fn\nWrap member function pointer:\nstruct A {\n    void method(int n);\n};\n\nA a;\n\n// Raw member function pointer\nauto ptr = &A::method;\n(a.*ptr)(1);\n\n// With mem_fn\nauto wrapped = std::mem_fn(&A::method);\nwrapped(a, 2);  // cleaner syntax",
    "crumbs": [
      "Standard Library",
      "std::function and Functional"
    ]
  },
  {
    "objectID": "docs/stdlib/functional.html#key-points",
    "href": "docs/stdlib/functional.html#key-points",
    "title": "std::function and Functional",
    "section": "Key Points",
    "text": "Key Points\n\nstd::function has overhead (type erasure, possible heap)\nPrefer lambdas over std::bind (more readable)\nstd::invoke enables generic callable handling\nUse templates for zero-overhead function parameters",
    "crumbs": [
      "Standard Library",
      "std::function and Functional"
    ]
  },
  {
    "objectID": "docs/stdlib/functional.html#see-also",
    "href": "docs/stdlib/functional.html#see-also",
    "title": "std::function and Functional",
    "section": "See Also",
    "text": "See Also\n\nlambdas - lambda expressions",
    "crumbs": [
      "Standard Library",
      "std::function and Functional"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html",
    "href": "docs/stdlib/filesystem.html",
    "title": "std::filesystem",
    "section": "",
    "text": "Cross-platform file and directory operations.",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html#path-operations",
    "href": "docs/stdlib/filesystem.html#path-operations",
    "title": "std::filesystem",
    "section": "Path Operations",
    "text": "Path Operations\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n\nfs::path p = fs::current_path();\n\np.string();        // full path as string\np.root_path();     // root (e.g., \"/\" or \"C:\\\")\np.parent_path();   // directory containing this\np.filename();      // just the filename\np.extension();     // file extension\np.stem();          // filename without extension",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html#file-properties",
    "href": "docs/stdlib/filesystem.html#file-properties",
    "title": "std::filesystem",
    "section": "File Properties",
    "text": "File Properties\nfs::path p = \"file.txt\";\n\nfs::exists(p);           // does it exist?\nfs::is_regular_file(p);  // regular file?\nfs::is_directory(p);     // directory?\nfs::is_symlink(p);       // symbolic link?\n\nauto size = fs::file_size(p);  // size in bytes\nauto time = fs::last_write_time(p);",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html#directory-iteration",
    "href": "docs/stdlib/filesystem.html#directory-iteration",
    "title": "std::filesystem",
    "section": "Directory Iteration",
    "text": "Directory Iteration\n// Non-recursive\nfor (const auto& entry : fs::directory_iterator(dir)) {\n    entry.path();\n    entry.is_regular_file();\n}\n\n// Recursive (subdirectories too)\nfor (const auto& entry : fs::recursive_directory_iterator(dir)) {\n    entry.path();\n}",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html#modification-operations",
    "href": "docs/stdlib/filesystem.html#modification-operations",
    "title": "std::filesystem",
    "section": "Modification Operations",
    "text": "Modification Operations\nfs::create_directory(\"newdir\");\nfs::create_directories(\"a/b/c\");  // creates parents\n\nfs::copy(\"src\", \"dst\");\nfs::copy_file(\"src.txt\", \"dst.txt\");\n\nfs::rename(\"old\", \"new\");\n\nfs::remove(\"file\");       // single file/empty dir\nfs::remove_all(\"dir\");    // recursive delete",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html#path-manipulation",
    "href": "docs/stdlib/filesystem.html#path-manipulation",
    "title": "std::filesystem",
    "section": "Path Manipulation",
    "text": "Path Manipulation\nfs::path p = \"/home/user\";\np /= \"docs\";          // append with separator\np /= \"file.txt\";      // \"/home/user/docs/file.txt\"\n\nfs::path p2 = p.parent_path() / \"other.txt\";",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html#key-points",
    "href": "docs/stdlib/filesystem.html#key-points",
    "title": "std::filesystem",
    "section": "Key Points",
    "text": "Key Points\n\nCross-platform (Windows, Linux, macOS)\nBased on POSIX semantics\nOperations can throw filesystem_error\nUse error_code overloads to avoid exceptions\nC++20 adds more features",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/filesystem.html#see-also",
    "href": "docs/stdlib/filesystem.html#see-also",
    "title": "std::filesystem",
    "section": "See Also",
    "text": "See Also\n\nio - file I/O streams",
    "crumbs": [
      "Standard Library",
      "std::filesystem"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/string.html",
    "href": "docs/stdlib/containers/string.html",
    "title": "std::string",
    "section": "",
    "text": "Dynamic character sequence.",
    "crumbs": [
      "Standard Library",
      "std::string"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/string.html#conversions",
    "href": "docs/stdlib/containers/string.html#conversions",
    "title": "std::string",
    "section": "Conversions",
    "text": "Conversions\n#include &lt;string&gt;\n#include &lt;charconv&gt;\n\nusing namespace std::string_literals;\n\n// String to integer\nstd::string num = \"FF\"s;\nstd::size_t pos;\nint x = std::stoi(num, &pos, 16); // hex, pos = chars processed\n\n// C++17: faster, no allocation, no exceptions\nint y;\nstd::from_chars(num.data(), num.data() + num.size(), y, 16);\n\n// Integer to string\nint val = 255;\nstd::string s = std::to_string(val);",
    "crumbs": [
      "Standard Library",
      "std::string"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/string.html#string-literals",
    "href": "docs/stdlib/containers/string.html#string-literals",
    "title": "std::string",
    "section": "String Literals",
    "text": "String Literals\nusing namespace std::string_literals;\n\nauto s1 = \"hello\"s;        // std::string\nauto s2 = \"hello\";         // const char*\nauto s3 = \"hello\"sv;       // std::string_view (C++17)",
    "crumbs": [
      "Standard Library",
      "std::string"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/string.html#string_view-c17",
    "href": "docs/stdlib/containers/string.html#string_view-c17",
    "title": "std::string",
    "section": "string_view (C++17)",
    "text": "string_view (C++17)\nNon-owning reference to string data:\n#include &lt;string_view&gt;\n\nstd::string str = \"Hello, World!\";\nstd::string_view view = str;  // no copy\n\nvoid process(std::string_view sv);  // efficient parameter\nprocess(\"literal\");                  // no allocation\nprocess(str);                        // no copy",
    "crumbs": [
      "Standard Library",
      "std::string"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/string.html#key-points",
    "href": "docs/stdlib/containers/string.html#key-points",
    "title": "std::string",
    "section": "Key Points",
    "text": "Key Points\n\nstd::string owns its data\nstd::string_view is a non-owning view\nUse from_chars/to_chars for fast conversions\nString literals with s suffix create std::string\nPass string_view to functions for efficiency",
    "crumbs": [
      "Standard Library",
      "std::string"
    ]
  },
  {
    "objectID": "docs/stdlib/containers/string.html#see-also",
    "href": "docs/stdlib/containers/string.html#see-also",
    "title": "std::string",
    "section": "See Also",
    "text": "See Also\n\nio - string I/O",
    "crumbs": [
      "Standard Library",
      "std::string"
    ]
  },
  {
    "objectID": "docs/stdlib/optional.html",
    "href": "docs/stdlib/optional.html",
    "title": "std::optional",
    "section": "",
    "text": "Nullable value wrapper.",
    "crumbs": [
      "Standard Library",
      "std::optional"
    ]
  },
  {
    "objectID": "docs/stdlib/optional.html#basic-usage",
    "href": "docs/stdlib/optional.html#basic-usage",
    "title": "std::optional",
    "section": "Basic Usage",
    "text": "Basic Usage\n#include &lt;optional&gt;\n\nstd::optional&lt;int&gt; opt{42};\nstd::optional&lt;int&gt; none{std::nullopt};\n\nif (opt.has_value()) {\n    int x = *opt;        // dereference\n    int y = opt.value(); // with exception if empty\n}\n\n// value_or: default if empty\nint z = none.value_or(0); // z = 0",
    "crumbs": [
      "Standard Library",
      "std::optional"
    ]
  },
  {
    "objectID": "docs/stdlib/optional.html#creating-optional",
    "href": "docs/stdlib/optional.html#creating-optional",
    "title": "std::optional",
    "section": "Creating Optional",
    "text": "Creating Optional\nstd::optional&lt;std::string&gt; a = \"hello\";     // implicit\nstd::optional&lt;std::string&gt; b{\"hello\"};      // direct\nauto c = std::make_optional(\"hello\");       // deduced\nstd::optional&lt;std::string&gt; d = std::nullopt; // empty\nstd::optional&lt;std::string&gt; e;               // empty",
    "crumbs": [
      "Standard Library",
      "std::optional"
    ]
  },
  {
    "objectID": "docs/stdlib/optional.html#checking-and-accessing",
    "href": "docs/stdlib/optional.html#checking-and-accessing",
    "title": "std::optional",
    "section": "Checking and Accessing",
    "text": "Checking and Accessing\nstd::optional&lt;int&gt; opt = 42;\n\n// Check if has value\nif (opt) { }              // contextual bool\nif (opt.has_value()) { }  // explicit\n\n// Access value\n*opt;                     // UB if empty\nopt.value();              // throws if empty\nopt.value_or(default);    // safe default",
    "crumbs": [
      "Standard Library",
      "std::optional"
    ]
  },
  {
    "objectID": "docs/stdlib/optional.html#modifying",
    "href": "docs/stdlib/optional.html#modifying",
    "title": "std::optional",
    "section": "Modifying",
    "text": "Modifying\nopt = 100;          // assign new value\nopt = std::nullopt; // clear\nopt.reset();        // clear\nopt.emplace(200);   // construct in-place",
    "crumbs": [
      "Standard Library",
      "std::optional"
    ]
  },
  {
    "objectID": "docs/stdlib/optional.html#key-points",
    "href": "docs/stdlib/optional.html#key-points",
    "title": "std::optional",
    "section": "Key Points",
    "text": "Key Points\n\nReplaces “magic values” (like -1 for not found)\nSafer than raw pointers for optional values\nZero overhead when value is present\nUse value_or() for safe access with defaults\nGreat for function return types",
    "crumbs": [
      "Standard Library",
      "std::optional"
    ]
  },
  {
    "objectID": "docs/stdlib/optional.html#see-also",
    "href": "docs/stdlib/optional.html#see-also",
    "title": "std::optional",
    "section": "See Also",
    "text": "See Also\n\nvariant - multiple types\nany - any type",
    "crumbs": [
      "Standard Library",
      "std::optional"
    ]
  },
  {
    "objectID": "docs/stdlib/index.html",
    "href": "docs/stdlib/index.html",
    "title": "Standard Library",
    "section": "",
    "text": "C++ standard library components.",
    "crumbs": [
      "Standard Library"
    ]
  },
  {
    "objectID": "docs/stdlib/index.html#containers",
    "href": "docs/stdlib/index.html#containers",
    "title": "Standard Library",
    "section": "Containers",
    "text": "Containers\n\ncontainers/array - Fixed-size array\ncontainers/string - Dynamic string",
    "crumbs": [
      "Standard Library"
    ]
  },
  {
    "objectID": "docs/stdlib/index.html#vocabulary-types",
    "href": "docs/stdlib/index.html#vocabulary-types",
    "title": "Standard Library",
    "section": "Vocabulary Types",
    "text": "Vocabulary Types\n\noptional - Nullable value\nvariant - Type-safe union\nany - Type-erased container",
    "crumbs": [
      "Standard Library"
    ]
  },
  {
    "objectID": "docs/stdlib/index.html#utilities",
    "href": "docs/stdlib/index.html#utilities",
    "title": "Standard Library",
    "section": "Utilities",
    "text": "Utilities\n\nfunctional - Function wrappers\nchrono - Time utilities\nrandom - Random number generation\nnumeric - Math and numeric limits",
    "crumbs": [
      "Standard Library"
    ]
  },
  {
    "objectID": "docs/stdlib/index.html#system",
    "href": "docs/stdlib/index.html#system",
    "title": "Standard Library",
    "section": "System",
    "text": "System\n\nfilesystem - File operations\nio - Input/output streams",
    "crumbs": [
      "Standard Library"
    ]
  },
  {
    "objectID": "docs/thirdparty/gtest.html",
    "href": "docs/thirdparty/gtest.html",
    "title": "Google Test",
    "section": "",
    "text": "C++ testing framework.",
    "crumbs": [
      "Third-Party",
      "Google Test"
    ]
  },
  {
    "objectID": "docs/thirdparty/gtest.html#basic-test",
    "href": "docs/thirdparty/gtest.html#basic-test",
    "title": "Google Test",
    "section": "Basic Test",
    "text": "Basic Test\n#include &lt;gtest/gtest.h&gt;\n\nTEST(TestSuite, BasicAssertions) {\n    EXPECT_STRNE(\"hello\", \"world\");\n    EXPECT_EQ(7 * 6, 42);\n}",
    "crumbs": [
      "Third-Party",
      "Google Test"
    ]
  },
  {
    "objectID": "docs/thirdparty/gtest.html#assertions",
    "href": "docs/thirdparty/gtest.html#assertions",
    "title": "Google Test",
    "section": "Assertions",
    "text": "Assertions\n\n\n\nFatal\nNon-Fatal\nVerifies\n\n\n\n\nASSERT_TRUE(cond)\nEXPECT_TRUE(cond)\ncondition is true\n\n\nASSERT_FALSE(cond)\nEXPECT_FALSE(cond)\ncondition is false\n\n\nASSERT_EQ(a, b)\nEXPECT_EQ(a, b)\na == b\n\n\nASSERT_NE(a, b)\nEXPECT_NE(a, b)\na != b\n\n\nASSERT_LT(a, b)\nEXPECT_LT(a, b)\na &lt; b\n\n\nASSERT_LE(a, b)\nEXPECT_LE(a, b)\na &lt;= b\n\n\nASSERT_GT(a, b)\nEXPECT_GT(a, b)\na &gt; b\n\n\nASSERT_GE(a, b)\nEXPECT_GE(a, b)\na &gt;= b\n\n\nASSERT_STREQ(a, b)\nEXPECT_STREQ(a, b)\nC strings equal\n\n\nASSERT_STRNE(a, b)\nEXPECT_STRNE(a, b)\nC strings not equal\n\n\n\n\nASSERT_* - fatal, stops test on failure\nEXPECT_* - non-fatal, continues test on failure",
    "crumbs": [
      "Third-Party",
      "Google Test"
    ]
  },
  {
    "objectID": "docs/thirdparty/gtest.html#test-fixtures",
    "href": "docs/thirdparty/gtest.html#test-fixtures",
    "title": "Google Test",
    "section": "Test Fixtures",
    "text": "Test Fixtures\nShare setup/teardown across tests:\nclass TestFixture : public testing::Test {\n  protected:\n    void SetUp() override {\n        v1 = {1, 2, 3};\n        v2 = {1.0, 2.0, 3.0};\n    }\n\n    void TearDown() override {\n        // cleanup (optional)\n    }\n\n    std::vector&lt;int&gt; v1;\n    std::vector&lt;float&gt; v2;\n};\n\nTEST_F(TestFixture, VectorSize) {\n    ASSERT_TRUE(!v1.empty());\n    EXPECT_EQ(v1.size(), v2.size());\n}\n\nTEST_F(TestFixture, VectorElement) {\n    for (std::size_t i = 0; i &lt; v1.size(); ++i) {\n        EXPECT_EQ(v1[i], v2[i]);\n    }\n}",
    "crumbs": [
      "Third-Party",
      "Google Test"
    ]
  },
  {
    "objectID": "docs/thirdparty/gtest.html#parameterized-tests",
    "href": "docs/thirdparty/gtest.html#parameterized-tests",
    "title": "Google Test",
    "section": "Parameterized Tests",
    "text": "Parameterized Tests\nRun same test with different inputs:\nclass TestParametrized : public testing::TestWithParam&lt;int&gt; {\n  protected:\n    int foo(int x) { return (x + 3) % 5 == 0; }\n};\n\nTEST_P(TestParametrized, Test) {\n    int x = GetParam();\n    EXPECT_TRUE(foo(x));\n}\n\nINSTANTIATE_TEST_SUITE_P(InstantiationName, TestParametrized,\n                         testing::Values(2, 4, 6, 8));",
    "crumbs": [
      "Third-Party",
      "Google Test"
    ]
  },
  {
    "objectID": "docs/thirdparty/gtest.html#key-points",
    "href": "docs/thirdparty/gtest.html#key-points",
    "title": "Google Test",
    "section": "Key Points",
    "text": "Key Points\n\nTEST() for simple tests\nTEST_F() for fixture-based tests\nTEST_P() for parameterized tests\nASSERT_* stops on failure, EXPECT_* continues\nSetUp()/TearDown() for fixture lifecycle",
    "crumbs": [
      "Third-Party",
      "Google Test"
    ]
  },
  {
    "objectID": "docs/thirdparty/gtest.html#see-also",
    "href": "docs/thirdparty/gtest.html#see-also",
    "title": "Google Test",
    "section": "See Also",
    "text": "See Also\n\nfmt - output formatting in tests",
    "crumbs": [
      "Third-Party",
      "Google Test"
    ]
  },
  {
    "objectID": "docs/thirdparty/index.html",
    "href": "docs/thirdparty/index.html",
    "title": "Third-Party Libraries",
    "section": "",
    "text": "Popular libraries that extend C++ capabilities.",
    "crumbs": [
      "Third-Party"
    ]
  },
  {
    "objectID": "docs/thirdparty/index.html#topics",
    "href": "docs/thirdparty/index.html#topics",
    "title": "Third-Party Libraries",
    "section": "Topics",
    "text": "Topics\n\nfmt - Modern formatting library\ngtest - Google Test framework",
    "crumbs": [
      "Third-Party"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html",
    "href": "docs/core/lambdas.html",
    "title": "Lambda Expressions",
    "section": "",
    "text": "Anonymous function objects.",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#syntax",
    "href": "docs/core/lambdas.html#syntax",
    "title": "Lambda Expressions",
    "section": "Syntax",
    "text": "Syntax\nauto lambda = [capture](parameters) { body };",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#basic-usage",
    "href": "docs/core/lambdas.html#basic-usage",
    "title": "Lambda Expressions",
    "section": "Basic Usage",
    "text": "Basic Usage\nauto add = [](int a, int b) { return a + b; };\nint result = add(2, 3); // 5",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#generic-lambdas-c14",
    "href": "docs/core/lambdas.html#generic-lambdas-c14",
    "title": "Lambda Expressions",
    "section": "Generic Lambdas (C++14)",
    "text": "Generic Lambdas (C++14)\nauto g = [](auto x, auto y) { return x + y; };\ng(1, 2);     // int\ng(1.5, 2.5); // double",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#default-parameters-c14",
    "href": "docs/core/lambdas.html#default-parameters-c14",
    "title": "Lambda Expressions",
    "section": "Default Parameters (C++14)",
    "text": "Default Parameters (C++14)\nauto h = [](int x = 0) { return x; };\nh();  // 0\nh(5); // 5",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#constexpr-lambdas-c17",
    "href": "docs/core/lambdas.html#constexpr-lambdas-c17",
    "title": "Lambda Expressions",
    "section": "constexpr Lambdas (C++17)",
    "text": "constexpr Lambdas (C++17)\nauto factorial = [](int n) constexpr {\n    int result = 1;\n    for (int i = 2; i &lt;= n; ++i)\n        result *= i;\n    return result;\n};\n\nconstexpr int f10 = factorial(10); // compile-time",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#capture-modes",
    "href": "docs/core/lambdas.html#capture-modes",
    "title": "Lambda Expressions",
    "section": "Capture Modes",
    "text": "Capture Modes\nint x = 10;\n\n[x]  { return x; }     // by value (const copy)\n[&x] { return x; }     // by reference\n[=]  { return x; }     // all by value\n[&]  { return x; }     // all by reference\n[=, &x] { }            // all by value, x by reference\n[&, x]  { }            // all by reference, x by value",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#mutable-lambdas",
    "href": "docs/core/lambdas.html#mutable-lambdas",
    "title": "Lambda Expressions",
    "section": "Mutable Lambdas",
    "text": "Mutable Lambdas\nBy default, captured values are const. Use mutable to modify:\nint x = 0;\nauto f = [x]() mutable {\n    x = 1;      // OK: mutable allows modification\n    return x;\n};\nf(); // returns 1\n// x is still 0 (captured by value)",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#key-points",
    "href": "docs/core/lambdas.html#key-points",
    "title": "Lambda Expressions",
    "section": "Key Points",
    "text": "Key Points\n\nLambdas are syntactic sugar for anonymous functor classes\nCapture by value creates const copies by default\nUse mutable to modify value-captured variables\nGeneric lambdas use auto parameters\nC++20 adds template lambdas: []&lt;typename T&gt;(T x) { }",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/lambdas.html#see-also",
    "href": "docs/core/lambdas.html#see-also",
    "title": "Lambda Expressions",
    "section": "See Also",
    "text": "See Also\n\nfunctions - regular functions\nfunctional - std::function wrapper",
    "crumbs": [
      "Core",
      "Lambda Expressions"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html",
    "href": "docs/core/constexpr.html",
    "title": "constexpr",
    "section": "",
    "text": "Enables compile-time evaluation for variables and functions.",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html#usage",
    "href": "docs/core/constexpr.html#usage",
    "title": "constexpr",
    "section": "Usage",
    "text": "Usage\nconstexpr int square(int x) {\n    return x * x;\n}\n\nint main() {\n    constexpr int x = square(5); // evaluated at compile-time\n    static_assert(x == 25);\n}",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html#constexpr-variables",
    "href": "docs/core/constexpr.html#constexpr-variables",
    "title": "constexpr",
    "section": "constexpr Variables",
    "text": "constexpr Variables\nconstexpr int x = 5;\nconstexpr int y = x * 2; // evaluated at compile-time\nconstexpr int z = square(8);",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html#constexpr-functions",
    "href": "docs/core/constexpr.html#constexpr-functions",
    "title": "constexpr",
    "section": "constexpr Functions",
    "text": "constexpr Functions\nconstexpr int square(int x) {\n    return x * x;\n}\nEvaluated at compile-time when: - All arguments are constant expressions - Result is used in a constant context\nLimitations: - No runtime features - No goto, asm, assert - No static variables - No undefined behavior - Cannot be virtual (until C++20)",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html#constexpr-classes",
    "href": "docs/core/constexpr.html#constexpr-classes",
    "title": "constexpr",
    "section": "constexpr Classes",
    "text": "constexpr Classes\nstruct S {\n    int x{7};\n    constexpr S(int x) : x(x) {}\n    constexpr int f() const { return x; }\n    static constexpr int g() { return 42; }\n};\n\nconstexpr S s(10);\nconstexpr int a = s.f(); // OK: s is constexpr",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html#if-constexpr-c17",
    "href": "docs/core/constexpr.html#if-constexpr-c17",
    "title": "constexpr",
    "section": "if constexpr (C++17)",
    "text": "if constexpr (C++17)\nCompile-time conditional:\nif constexpr (sizeof(int) == 4) {\n    return 1;\n} else if constexpr (sizeof(int) == 8) {\n    return 2;\n}\nThe non-taken branch is discarded entirely (useful in templates).",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html#key-points",
    "href": "docs/core/constexpr.html#key-points",
    "title": "constexpr",
    "section": "Key Points",
    "text": "Key Points\n\nconstexpr can be evaluated at compile-time (not must)\nAll arguments must be constexpr for compile-time evaluation\nC++14 added loops and local variables\nC++17 added if constexpr\nC++20 relaxed many restrictions",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/constexpr.html#see-also",
    "href": "docs/core/constexpr.html#see-also",
    "title": "constexpr",
    "section": "See Also",
    "text": "See Also\n\nconst - runtime immutability",
    "crumbs": [
      "Core",
      "constexpr"
    ]
  },
  {
    "objectID": "docs/core/functions.html",
    "href": "docs/core/functions.html",
    "title": "Functions",
    "section": "",
    "text": "Function declarations, overloading, and function pointers.",
    "crumbs": [
      "Core",
      "Functions"
    ]
  },
  {
    "objectID": "docs/core/functions.html#function-signature",
    "href": "docs/core/functions.html#function-signature",
    "title": "Functions",
    "section": "Function Signature",
    "text": "Function Signature\nA function signature includes: - Number of arguments - Argument types - Order of arguments\nvoid f(int);\nvoid f(double) = delete; // explicitly delete overload",
    "crumbs": [
      "Core",
      "Functions"
    ]
  },
  {
    "objectID": "docs/core/functions.html#deleted-functions",
    "href": "docs/core/functions.html#deleted-functions",
    "title": "Functions",
    "section": "Deleted Functions",
    "text": "Deleted Functions\nvoid g(int*);\nvoid g(std::nullptr_t) = delete; // prevent nullptr overload",
    "crumbs": [
      "Core",
      "Functions"
    ]
  },
  {
    "objectID": "docs/core/functions.html#function-pointers",
    "href": "docs/core/functions.html#function-pointers",
    "title": "Functions",
    "section": "Function Pointers",
    "text": "Function Pointers\n// fp takes two ints and returns int\nvoid use(int (*fp)(int, int));\n\n// Complex declaration (read inside-out):\n// fp is a pointer to function taking int,\n// returning pointer to array of 10 pointers to int\nvoid complex(int* (*(*fp)(int))[10]);",
    "crumbs": [
      "Core",
      "Functions"
    ]
  },
  {
    "objectID": "docs/core/functions.html#functors",
    "href": "docs/core/functions.html#functors",
    "title": "Functions",
    "section": "Functors",
    "text": "Functors\nA functor is a class with operator():\nstruct Functor {\n    void operator()() { /* ... */ }\n};\n\nFunctor f;\nf(); // callable like a function\nSince C++11, lambdas often replace functors.",
    "crumbs": [
      "Core",
      "Functions"
    ]
  },
  {
    "objectID": "docs/core/functions.html#key-points",
    "href": "docs/core/functions.html#key-points",
    "title": "Functions",
    "section": "Key Points",
    "text": "Key Points\n\nOverloading: same name, different signatures\nUse = delete to explicitly forbid overloads\nRead complex pointer declarations inside-out\nFunctors are objects that behave like functions",
    "crumbs": [
      "Core",
      "Functions"
    ]
  },
  {
    "objectID": "docs/core/functions.html#see-also",
    "href": "docs/core/functions.html#see-also",
    "title": "Functions",
    "section": "See Also",
    "text": "See Also\n\nlambdas - lambda expressions\nfunctional - std::function",
    "crumbs": [
      "Core",
      "Functions"
    ]
  },
  {
    "objectID": "docs/core/const.html",
    "href": "docs/core/const.html",
    "title": "const",
    "section": "",
    "text": "The const qualifier marks variables as immutable.",
    "crumbs": [
      "Core",
      "const"
    ]
  },
  {
    "objectID": "docs/core/const.html#usage",
    "href": "docs/core/const.html#usage",
    "title": "const",
    "section": "Usage",
    "text": "Usage\nconst int x = 5;\nconst char s[] = \"Hello\";",
    "crumbs": [
      "Core",
      "const"
    ]
  },
  {
    "objectID": "docs/core/const.html#pointers-and-const",
    "href": "docs/core/const.html#pointers-and-const",
    "title": "const",
    "section": "Pointers and const",
    "text": "Pointers and const\nint y = 10;\n\nconst int* p1 = &y;       // pointer to const int (can't modify *p1)\nint* const p2 = &y;       // const pointer to int (can't modify p2)\nconst int* const p3 = &y; // const pointer to const int",
    "crumbs": [
      "Core",
      "const"
    ]
  },
  {
    "objectID": "docs/core/const.html#type-alias-gotcha",
    "href": "docs/core/const.html#type-alias-gotcha",
    "title": "const",
    "section": "Type Alias Gotcha",
    "text": "Type Alias Gotcha\nusing ptr_t = int*;\nconst ptr_t p4 = &y; // This is: int* const (not const int*)\n*p4 = 5;             // Allowed! p4 points to non-const int\nThe const applies to the alias as a whole, making the pointer const, not what it points to.",
    "crumbs": [
      "Core",
      "const"
    ]
  },
  {
    "objectID": "docs/core/const.html#key-points",
    "href": "docs/core/const.html#key-points",
    "title": "const",
    "section": "Key Points",
    "text": "Key Points\n\nconst variables must be initialized at declaration\nRead pointer declarations right-to-left\nType aliases can be surprising with const\nconst member functions can be called on const objects",
    "crumbs": [
      "Core",
      "const"
    ]
  },
  {
    "objectID": "docs/core/const.html#see-also",
    "href": "docs/core/const.html#see-also",
    "title": "const",
    "section": "See Also",
    "text": "See Also\n\nconstexpr - compile-time evaluation\nvolatile - volatile qualifier",
    "crumbs": [
      "Core",
      "const"
    ]
  },
  {
    "objectID": "docs/core/enums.html",
    "href": "docs/core/enums.html",
    "title": "Enumerations",
    "section": "",
    "text": "Type-safe enumerated constants.",
    "crumbs": [
      "Core",
      "Enumerations"
    ]
  },
  {
    "objectID": "docs/core/enums.html#traditional-enum-unscoped",
    "href": "docs/core/enums.html#traditional-enum-unscoped",
    "title": "Enumerations",
    "section": "Traditional enum (Unscoped)",
    "text": "Traditional enum (Unscoped)\nenum Color { RED, GREEN, BLUE };\nenum Fruit { APPLE, BANANA, CHERRY };\n\nColor c = RED;\nFruit f = APPLE;\n\n// Problem: implicitly converts to int, allows comparison\nif (c == f) { } // Compiles! RED == APPLE (both are 0)\nint x = GREEN + CHERRY; // Compiles! 1 + 2 = 3",
    "crumbs": [
      "Core",
      "Enumerations"
    ]
  },
  {
    "objectID": "docs/core/enums.html#enum-class-scoped-c11",
    "href": "docs/core/enums.html#enum-class-scoped-c11",
    "title": "Enumerations",
    "section": "enum class (Scoped, C++11)",
    "text": "enum class (Scoped, C++11)\nenum class Animal { dog, deer, cat, bird, human };\nenum class Mammal { kangaroo, deer, human };\n\nAnimal a = Animal::dog;\n// Animal b = dog;        // Error: must use scope\n// if (a == Mammal::deer) // Error: different types",
    "crumbs": [
      "Core",
      "Enumerations"
    ]
  },
  {
    "objectID": "docs/core/enums.html#features",
    "href": "docs/core/enums.html#features",
    "title": "Enumerations",
    "section": "Features",
    "text": "Features\n// Automatic values starting from 0\nstatic_assert(static_cast&lt;int&gt;(Animal::bird) == 3);\n\n// Comparison within same enum\nstatic_assert(Animal::dog &lt; Animal::deer);\n\n// Explicit underlying type and values\nenum class Foo : uint8_t {\n    A = 1,\n    B = 4,\n    C [[deprecated]] = 255, // with attributes\n    D = 0,\n    E = 1  // aliasing allowed (E == A)\n};\n\nstatic_assert(std::is_same_v&lt;std::underlying_type_t&lt;Foo&gt;, uint8_t&gt;);\nstatic_assert(Foo::A == Foo::E);",
    "crumbs": [
      "Core",
      "Enumerations"
    ]
  },
  {
    "objectID": "docs/core/enums.html#key-points",
    "href": "docs/core/enums.html#key-points",
    "title": "Enumerations",
    "section": "Key Points",
    "text": "Key Points\n\nPrefer enum class over plain enum\nScoped enums require explicit conversion to integers\nCan specify underlying type (default is int)\nSupports attributes like [[deprecated]]\nValues can alias (multiple names for same value)",
    "crumbs": [
      "Core",
      "Enumerations"
    ]
  },
  {
    "objectID": "docs/core/enums.html#see-also",
    "href": "docs/core/enums.html#see-also",
    "title": "Enumerations",
    "section": "See Also",
    "text": "See Also\n\ntypes - type system overview\nattributes - C++ attributes",
    "crumbs": [
      "Core",
      "Enumerations"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html",
    "href": "docs/core/preprocessor.html",
    "title": "Preprocessor",
    "section": "",
    "text": "Directives processed before compilation.",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#macros",
    "href": "docs/core/preprocessor.html#macros",
    "title": "Preprocessor",
    "section": "Macros",
    "text": "Macros\n#define VAL 10\n#undef VAL\n\n#define STR(s) #s   // stringizing: STR(hello) -&gt; \"hello\"\n#define CONCAT(a, b) a##b  // token pasting: CONCAT(foo, bar) -&gt; foobar",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#conditional-compilation",
    "href": "docs/core/preprocessor.html#conditional-compilation",
    "title": "Preprocessor",
    "section": "Conditional Compilation",
    "text": "Conditional Compilation\n#if defined(DEBUG)\n    // debug code\n#elif !defined(RELEASE)\n    // neither debug nor release\n#else\n    // release code\n#endif\n\n// Shorthand\n#ifdef DEBUG\n#ifndef RELEASE",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#feature-testing-c17",
    "href": "docs/core/preprocessor.html#feature-testing-c17",
    "title": "Preprocessor",
    "section": "Feature Testing (C++17)",
    "text": "Feature Testing (C++17)\n#if __has_include(&lt;optional&gt;)\n#include &lt;optional&gt;\n#endif",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#predefined-macros",
    "href": "docs/core/preprocessor.html#predefined-macros",
    "title": "Preprocessor",
    "section": "Predefined Macros",
    "text": "Predefined Macros\n\nSource Location\n__FILE__            // current filename\n__LINE__            // current line number\n__func__            // current function name (C99/C++11)\n__FUNCTION__        // same as __func__ (common extension)\n__PRETTY_FUNCTION__ // decorated function name (GCC/Clang)\n\n\nLanguage Version\n#if __cplusplus == 199711L\n    // C++98\n#elif __cplusplus == 201103L\n    // C++11\n#elif __cplusplus == 201402L\n    // C++14\n#elif __cplusplus == 201703L\n    // C++17\n#elif __cplusplus == 202002L\n    // C++20\n#endif\n\n\nCompiler Detection\n#ifdef __GNUG__     // GCC/G++\n#ifdef __clang__    // Clang\n#ifdef _MSC_VER     // MSVC\n\n\nPlatform Detection\n#ifdef __linux__    // Linux\n#ifdef _WIN32       // Windows (32 and 64-bit)\n#ifdef _WIN64       // Windows 64-bit only\n#ifdef __APPLE__    // macOS/iOS\n#ifdef __unix__     // Unix-like",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#pragma",
    "href": "docs/core/preprocessor.html#pragma",
    "title": "Preprocessor",
    "section": "Pragma",
    "text": "Pragma\n#pragma once        // include guard (non-standard but universal)\n#pragma message(\"Building module X\")",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#code-generation",
    "href": "docs/core/preprocessor.html#code-generation",
    "title": "Preprocessor",
    "section": "Code Generation",
    "text": "Code Generation\n#define FUNC_GEN(type) \\\n    void to_##type() { /* ... */ }\n\nFUNC_GEN(int)   // generates: void to_int() { ... }\nFUNC_GEN(float) // generates: void to_float() { ... }",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#key-points",
    "href": "docs/core/preprocessor.html#key-points",
    "title": "Preprocessor",
    "section": "Key Points",
    "text": "Key Points\n\nPreprocessor runs before compilation\n# stringizes, ## concatenates tokens\nUse #pragma once or include guards\nPrefer constexpr and templates over macros when possible\n__cplusplus tells you the C++ standard version",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/preprocessor.html#see-also",
    "href": "docs/core/preprocessor.html#see-also",
    "title": "Preprocessor",
    "section": "See Also",
    "text": "See Also\n\nconstexpr - compile-time evaluation (prefer over macros)",
    "crumbs": [
      "Core",
      "Preprocessor"
    ]
  },
  {
    "objectID": "docs/core/index.html",
    "href": "docs/core/index.html",
    "title": "Core",
    "section": "",
    "text": "Fundamental C++ language features.",
    "crumbs": [
      "Core"
    ]
  },
  {
    "objectID": "docs/core/index.html#topics",
    "href": "docs/core/index.html#topics",
    "title": "Core",
    "section": "Topics",
    "text": "Topics\n\ntypes - Fundamental and compound types\nconst - Const qualifier\nconstexpr - Compile-time evaluation\nvolatile - Volatile qualifier\ninitialization - Variable initialization rules\nenums - Enumerations\nstructs - Structures\nbitfields - Bit fields\nunions - Unions\nfunctions - Function declarations\nlambdas - Lambda expressions\nnamespaces - Namespaces\nattributes - Attributes\npreprocessor - Preprocessor directives",
    "crumbs": [
      "Core"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html",
    "href": "docs/memory/allocation.html",
    "title": "Memory Allocation",
    "section": "",
    "text": "Dynamic memory management with new/delete.",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html#stack-vs-heap",
    "href": "docs/memory/allocation.html#stack-vs-heap",
    "title": "Memory Allocation",
    "section": "Stack vs Heap",
    "text": "Stack vs Heap\nvoid stack_allocation() {\n    int a = 42;             // stack\n    int b[5] = {1,2,3,4,5}; // stack\n    char s[] = \"Hello\";     // stack (array copied)\n    const char* p = \"World\"; // p on stack, string in read-only section\n}",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html#basic-dynamic-allocation",
    "href": "docs/memory/allocation.html#basic-dynamic-allocation",
    "title": "Memory Allocation",
    "section": "Basic Dynamic Allocation",
    "text": "Basic Dynamic Allocation\nint* a = new int;        // uninitialized\nint* b = new int(13);    // initialized to 13\nint* c = new int{13};    // same, uniform initialization\n\ndelete a;\ndelete b;\ndelete c;",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html#array-allocation",
    "href": "docs/memory/allocation.html#array-allocation",
    "title": "Memory Allocation",
    "section": "Array Allocation",
    "text": "Array Allocation\nint* arr1 = new int[5];           // 1D array\nauto* arr2 = new int[3][2];       // 2D array (C++11)\n// Note: second dimension must be constant\n\ndelete[] arr1;\ndelete[] arr2;",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html#placement-new",
    "href": "docs/memory/allocation.html#placement-new",
    "title": "Memory Allocation",
    "section": "Placement new",
    "text": "Placement new\nConstruct in pre-allocated memory:\nalignas(std::string) char buffer[sizeof(std::string)];\nstd::string* s = new (buffer) std::string(\"Hello\");\n\n// Must manually call destructor!\ns-&gt;~basic_string();\n// Don't delete - memory wasn't from new",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html#nothrow-allocation",
    "href": "docs/memory/allocation.html#nothrow-allocation",
    "title": "Memory Allocation",
    "section": "Nothrow Allocation",
    "text": "Nothrow Allocation\nint* p1 = new int[100];                // throws std::bad_alloc on failure\nint* p2 = new (std::nothrow) int[100]; // returns nullptr on failure\n\nif (p2 == nullptr) {\n    // handle allocation failure\n}",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html#key-points",
    "href": "docs/memory/allocation.html#key-points",
    "title": "Memory Allocation",
    "section": "Key Points",
    "text": "Key Points\n\nnew allocates and constructs, delete destructs and deallocates\nUse delete[] for arrays allocated with new[]\nPlacement new requires manual destructor call\nPrefer smart pointers over raw new/delete",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/allocation.html#see-also",
    "href": "docs/memory/allocation.html#see-also",
    "title": "Memory Allocation",
    "section": "See Also",
    "text": "See Also\n\nraii - automatic resource management",
    "crumbs": [
      "Memory",
      "Memory Allocation"
    ]
  },
  {
    "objectID": "docs/memory/index.html",
    "href": "docs/memory/index.html",
    "title": "Memory",
    "section": "",
    "text": "Memory and resource management.",
    "crumbs": [
      "Memory"
    ]
  },
  {
    "objectID": "docs/memory/index.html#topics",
    "href": "docs/memory/index.html#topics",
    "title": "Memory",
    "section": "Topics",
    "text": "Topics\n\nallocation - Dynamic memory allocation\nmemory-order - Atomic memory ordering",
    "crumbs": [
      "Memory"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html",
    "href": "docs/templates/deduction.html",
    "title": "Template Argument Deduction",
    "section": "",
    "text": "How the compiler infers template arguments.",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#basic-deduction",
    "href": "docs/templates/deduction.html#basic-deduction",
    "title": "Template Argument Deduction",
    "section": "Basic Deduction",
    "text": "Basic Deduction\ntemplate &lt;typename T&gt;\nT max(T a, T b);\n\nmax(1, 2);       // T = int\nmax(1.0, 2.0);   // T = double\n// max(1, 2.0);  // ERROR: T ambiguous\n\nconst int a = 1, b = 2;\nmax(a, b);       // T = int (const stripped)\n\nint arr[3];\nint* p;\nmax(&arr[0], p); // T = int*",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#return-type-deduction",
    "href": "docs/templates/deduction.html#return-type-deduction",
    "title": "Template Argument Deduction",
    "section": "Return Type Deduction",
    "text": "Return Type Deduction\n// Explicit return type parameter\ntemplate &lt;typename RT, typename T1, typename T2&gt;\nRT f1(T1 a, T2 b) { return a + b; }\nf1&lt;double&gt;(1, 2); // RT = double\n\n// Auto return (C++14)\ntemplate &lt;typename T1, typename T2&gt;\nauto f2(T1 a, T2 b) { return a + b; }\n\n// Trailing return type (C++11)\ntemplate &lt;typename T1, typename T2&gt;\nauto f3(T1 a, T2 b) -&gt; decltype(a + b) {\n    return a + b;\n}\n\n// std::common_type\ntemplate &lt;typename T1, typename T2&gt;\nstd::common_type_t&lt;T1, T2&gt; f4(T1 a, T2 b) {\n    return a + b;\n}",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#arrays-and-c-strings",
    "href": "docs/templates/deduction.html#arrays-and-c-strings",
    "title": "Template Argument Deduction",
    "section": "Arrays and C-Strings",
    "text": "Arrays and C-Strings\ntemplate &lt;typename T&gt;\nvoid foo(const T& t);  // reference: preserves array type\n\ntemplate &lt;typename T&gt;\nvoid bar(T t);         // value: array decays to pointer\n\nint arr[3];\nfoo(arr);     // T = int[3]\nbar(arr);     // T = int* (decay!)\n\nfoo(\"hello\"); // T = char[6]\nbar(\"hello\"); // T = const char* (decay!)",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#preserving-array-size",
    "href": "docs/templates/deduction.html#preserving-array-size",
    "title": "Template Argument Deduction",
    "section": "Preserving Array Size",
    "text": "Preserving Array Size\ntemplate &lt;typename T, std::size_t N&gt;\nvoid process(const T (&arr)[N]);\n\nint arr[5];\nprocess(arr);    // T = int, N = 5\nprocess(\"hi\");   // T = char, N = 3",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#class-template-argument-deduction-ctad-c17",
    "href": "docs/templates/deduction.html#class-template-argument-deduction-ctad-c17",
    "title": "Template Argument Deduction",
    "section": "Class Template Argument Deduction (CTAD, C++17)",
    "text": "Class Template Argument Deduction (CTAD, C++17)\nstd::pair p(1, 3.14);        // pair&lt;int, double&gt;\nstd::vector v{1, 2, 3};      // vector&lt;int&gt;\nstd::array a{1, 2, 3};       // array&lt;int, 3&gt;",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#deduction-guides",
    "href": "docs/templates/deduction.html#deduction-guides",
    "title": "Template Argument Deduction",
    "section": "Deduction Guides",
    "text": "Deduction Guides\ntemplate &lt;typename T&gt;\nstruct Container {\n    Container(T) {}\n};\n\n// Deduction guide: const char* -&gt; std::string\nContainer(const char*) -&gt; Container&lt;std::string&gt;;\n\nContainer c(\"hello\"); // Container&lt;std::string&gt;",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#key-points",
    "href": "docs/templates/deduction.html#key-points",
    "title": "Template Argument Deduction",
    "section": "Key Points",
    "text": "Key Points\n\nDeduction strips top-level const/reference\nArrays decay to pointers when passed by value\nUse references to preserve array types\ndecltype and auto help with return types\nCTAD eliminates explicit template arguments for classes\nDeduction guides customize CTAD behavior",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/deduction.html#see-also",
    "href": "docs/templates/deduction.html#see-also",
    "title": "Template Argument Deduction",
    "section": "See Also",
    "text": "See Also\n\nbasics - template fundamentals\ntype-traits - type manipulation",
    "crumbs": [
      "Templates",
      "Template Argument Deduction"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html",
    "href": "docs/templates/metaprogramming.html",
    "title": "Template Metaprogramming",
    "section": "",
    "text": "Compile-time computation using templates.",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html#classic-example-factorial",
    "href": "docs/templates/metaprogramming.html#classic-example-factorial",
    "title": "Template Metaprogramming",
    "section": "Classic Example: Factorial",
    "text": "Classic Example: Factorial\n// Template metaprogramming approach\ntemplate &lt;int N&gt;\nstruct Factorial {\n    static constexpr int value = N * Factorial&lt;N - 1&gt;::value;\n};\n\ntemplate &lt;&gt;\nstruct Factorial&lt;0&gt; {\n    static constexpr int value = 1;\n};\n\nstatic_assert(Factorial&lt;5&gt;::value == 120);",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html#modern-alternative-constexpr",
    "href": "docs/templates/metaprogramming.html#modern-alternative-constexpr",
    "title": "Template Metaprogramming",
    "section": "Modern Alternative: constexpr",
    "text": "Modern Alternative: constexpr\nconstexpr int factorial(int n) {\n    int result = 1;\n    for (int i = 2; i &lt;= n; ++i)\n        result *= i;\n    return result;\n}\n\nstatic_assert(factorial(5) == 120);",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html#log2-at-compile-time",
    "href": "docs/templates/metaprogramming.html#log2-at-compile-time",
    "title": "Template Metaprogramming",
    "section": "Log2 at Compile Time",
    "text": "Log2 at Compile Time\ntemplate &lt;int N&gt;\nstruct Log2 {\n    static_assert(N &gt; 0);\n    static constexpr int value = 1 + Log2&lt;N / 2&gt;::value;\n};\n\ntemplate &lt;&gt;\nstruct Log2&lt;1&gt; {\n    static constexpr int value = 0;\n};\n\nstatic_assert(Log2&lt;8&gt;::value == 3);\nstatic_assert(Log2&lt;1024&gt;::value == 10);",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html#compile-time-max",
    "href": "docs/templates/metaprogramming.html#compile-time-max",
    "title": "Template Metaprogramming",
    "section": "Compile-Time Max",
    "text": "Compile-Time Max\ntemplate &lt;int A, int B&gt;\nstruct Max {\n    static constexpr int value = (A &gt; B) ? A : B;\n};\n\nstatic_assert(Max&lt;3, 7&gt;::value == 7);",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html#practical-uses",
    "href": "docs/templates/metaprogramming.html#practical-uses",
    "title": "Template Metaprogramming",
    "section": "Practical Uses",
    "text": "Practical Uses\nMetaprogramming enables:\n\nCompile-time validation\ntemplate &lt;int N&gt;\nstruct Buffer {\n    static_assert(N &gt; 0 && N &lt;= 1024);\n    char data[N];\n};\nType computation\ntemplate &lt;typename T&gt;\nusing Ptr = T*;\n\ntemplate &lt;typename T, int N&gt;\nstruct ArrayType {\n    using type = T[N];\n};\nConditional types\ntemplate &lt;bool B, typename T, typename F&gt;\nstruct conditional { using type = T; };\n\ntemplate &lt;typename T, typename F&gt;\nstruct conditional&lt;false, T, F&gt; { using type = F; };",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html#key-points",
    "href": "docs/templates/metaprogramming.html#key-points",
    "title": "Template Metaprogramming",
    "section": "Key Points",
    "text": "Key Points\n\nTemplates can compute at compile time\nBase case via specialization\nPrefer constexpr functions for simple computations\nTemplate metaprogramming for type manipulation\nModern C++ (constexpr, if constexpr) often simpler",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/metaprogramming.html#see-also",
    "href": "docs/templates/metaprogramming.html#see-also",
    "title": "Template Metaprogramming",
    "section": "See Also",
    "text": "See Also\n\ntype-traits - standard metafunctions\nvariadic - compile-time recursion patterns",
    "crumbs": [
      "Templates",
      "Template Metaprogramming"
    ]
  },
  {
    "objectID": "docs/templates/basics.html",
    "href": "docs/templates/basics.html",
    "title": "Template Basics",
    "section": "",
    "text": "Generic programming with function, class, and variable templates.",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/basics.html#function-templates",
    "href": "docs/templates/basics.html#function-templates",
    "title": "Template Basics",
    "section": "Function Templates",
    "text": "Function Templates\ntemplate &lt;typename T&gt;\nT add(T a, T b) {\n    return a + b;\n}\n\nadd(1, 2);     // T = int (deduced)\nadd(1.0, 2.0); // T = double (deduced)\nadd&lt;float&gt;(1, 2); // T = float (explicit)",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/basics.html#template-parameters",
    "href": "docs/templates/basics.html#template-parameters",
    "title": "Template Basics",
    "section": "Template Parameters",
    "text": "Template Parameters\n// 1. Types\ntemplate &lt;typename T&gt; void f();\n\n// 2. Integral values\ntemplate &lt;int N&gt; int square() { return N * N; }\n\n// 3. auto (C++17)\ntemplate &lt;auto V&gt; auto get() { return V; }\n\n// 4. Enums\nenum class Dir { LEFT, RIGHT };\ntemplate &lt;Dir dir = Dir::RIGHT&gt;\nvoid move();\n\n// 5. Mixed\ntemplate &lt;int A, typename T&gt;\nT ceil_div(T b) { return (A + b - 1) / b; }",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/basics.html#class-templates",
    "href": "docs/templates/basics.html#class-templates",
    "title": "Template Basics",
    "section": "Class Templates",
    "text": "Class Templates\ntemplate &lt;typename T, typename U&gt;\nstruct Pair {\n    T first;\n    U second;\n};\n\nPair&lt;int, double&gt; p{1, 3.14};",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/basics.html#variable-templates-c14",
    "href": "docs/templates/basics.html#variable-templates-c14",
    "title": "Template Basics",
    "section": "Variable Templates (C++14)",
    "text": "Variable Templates (C++14)\ntemplate &lt;typename T&gt;\nconstexpr T pi = T(3.14159265358979L);\n\nfloat area = pi&lt;float&gt; * r * r;\ndouble area = pi&lt;double&gt; * r * r;",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/basics.html#template-instantiation",
    "href": "docs/templates/basics.html#template-instantiation",
    "title": "Template Basics",
    "section": "Template Instantiation",
    "text": "Template Instantiation\n// Implicit: generated when used\nadd(1, 2);\n\n// Explicit: force generation\ntemplate int add&lt;int&gt;(int, int);\n\n// Explicit specialization\ntemplate &lt;&gt;\nstd::string add&lt;std::string&gt;(std::string a, std::string b) {\n    return a + b;\n}",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/basics.html#key-points",
    "href": "docs/templates/basics.html#key-points",
    "title": "Template Basics",
    "section": "Key Points",
    "text": "Key Points\n\nTemplates are compile-time code generation\nType deduction infers template arguments\nExplicit instantiation useful for libraries\nSpecialization provides custom implementations\nC++17 added CTAD for classes",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/basics.html#see-also",
    "href": "docs/templates/basics.html#see-also",
    "title": "Template Basics",
    "section": "See Also",
    "text": "See Also\n\ndeduction - argument deduction rules\nspecialization - partial and full specialization",
    "crumbs": [
      "Templates",
      "Template Basics"
    ]
  },
  {
    "objectID": "docs/templates/index.html",
    "href": "docs/templates/index.html",
    "title": "Templates",
    "section": "",
    "text": "Generic programming and compile-time computation.",
    "crumbs": [
      "Templates"
    ]
  },
  {
    "objectID": "docs/templates/index.html#topics",
    "href": "docs/templates/index.html#topics",
    "title": "Templates",
    "section": "Topics",
    "text": "Topics\n\nbasics - Function, class, and variable templates\ndeduction - Template argument deduction and CTAD\nspecialization - Partial and full specialization\nvariadic - Parameter packs and fold expressions\nsfinae - Substitution failure and enable_if\ntype-traits - Type introspection and manipulation\nmetaprogramming - Compile-time computation",
    "crumbs": [
      "Templates"
    ]
  }
]